<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>github-pages</title>
    <url>/2023/04/09/github-pages/</url>
    <content><![CDATA[<h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><h2 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt; npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt; hexo init &lt;folder&gt;</span><br><span class="line">&gt; <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">&gt; npm install</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br><span class="line"></span><br><span class="line"><span class="built_in">Mode</span>                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">d----         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">31</span>                  .github</span><br><span class="line">d----         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">33</span>                  node_modules</span><br><span class="line">d----         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">31</span>                  scaffolds</span><br><span class="line">d----         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">31</span>                  source</span><br><span class="line">d----         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">31</span>                  themes</span><br><span class="line">-a---         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">31</span>              <span class="number">0</span>   _config.landscape.yml</span><br><span class="line">-a---         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">31</span>           <span class="number">2546</span>   _config.yml</span><br><span class="line">-a---         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">31</span>             <span class="number">89</span>   .gitignore</span><br><span class="line">-a---         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">33</span>          <span class="number">93385</span>   package-lock.json</span><br><span class="line">-a---         <span class="number">2023</span>/<span class="number">3</span>/<span class="number">31</span>     <span class="number">15</span>:<span class="number">31</span>            <span class="number">641</span>   package.json</span><br></pre></td></tr></table></figure>

<p>Starts a local server. By default, this is at <a href="http://localhost:4000/">http://localhost:4000/</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>pacman</title>
    <url>/2023/04/08/pacman/</url>
    <content><![CDATA[<p>最近有在 Windows 下编译 C++的需要，不想使用笨重的 Visual Studio，于是采用 MingGW，考虑到可能的包管理器需求，选择 MSYS2。MSYS2 的包管理采用的是来自 Arch Linux 的<br>pacman。它将简单的二进制包格式与易于使用的构建系统相结合。pacman 的目标是让轻松管理软件包成为可能，无论它们是来自官方仓库还是用户自己的构建。</p>
<p>Pacman 只需一个命令即可更新系统上的所有软件包。这可能需要相当长的时间，具体取决于系统的最新程度。以下命令同步存储库数据库并更新系统的软件包，不包括不在已配置存储库中的“本地”软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure>

<p>安装软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Ss string1 string2 ...</span><br></pre></td></tr></table></figure>

<p>要搜索已安装的软件包，请执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Qs string1 string2 ...</span><br></pre></td></tr></table></figure>

<p>查看包的依赖关系树：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pactree package_name</span><br></pre></td></tr></table></figure>

<p>安装软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S package_name1 package_name2 ...</span><br></pre></td></tr></table></figure>

<p>安装不是来自远程仓库的“本地”软件包（例如，该软件包来自 AUR）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -U /path/to/package/package_name-version.pkg.tar.zst</span><br></pre></td></tr></table></figure>

<p>要删除单个包，保留其所有依赖项，请执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -R package_name</span><br></pre></td></tr></table></figure>

<p>要删除任何其他已安装软件包不需要的软件包及其依赖项，请执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Rs package_name</span><br></pre></td></tr></table></figure>

<p>paccache（8） 脚本， 在 pacman-contrib 软件包中提供， 默认情况下会删除所有已安装和卸载的软件包的缓存版本， 除了最近的三个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paccache -r</span><br></pre></td></tr></table></figure>

<p>Pacman 通过与主服务器同步软件包列表来保持系统最新状态。此服务器&#x2F;客户端模型还允许用户使用简单的命令下载&#x2F;安装包，并完成所有必需的依赖项。</p>
<p>Pacman 是用 C 编程语言编写的， 使用 bsdtar（1） tar 格式进行打包。</p>
]]></content>
      <tags>
        <tag>包管理</tag>
        <tag>Linux</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title>spring AOP 真正代理的是 TargetSource</title>
    <url>/2023/07/18/spring-TargetSource/</url>
    <content><![CDATA[<p>我们在使用 spring AOP 功能时，可能认为 spring 为 bean 生成代理对象，其实 spring 是为 TargetSource 生成代理对象，利用 TargetSource，可以方便的修改 AOP 真正执行的对象，偷天换日。</p>
<span id="more"></span>

<p>TargetSource 顾名思义就是 target 的来源，这里的 target 指的是 AOP 执行过程中被反射调用方法的目标。<br>在 spring 的 AOP 执行过程中，TargetSource 用于获取反射的执行目标 target。如果一个 TargetSource，每次返回同一个 target，在 spring 中称其为静态（static），如果每次返回的不是同一个 target，具体的使用场景有 pooling 和 hot swapping。</p>
<p>TargetSource 这一抽象让 AOP 变得更加灵活，如果没有它，AOP 只能代理一个对象，每次执行只能调用同一个对象的方法。<br><img src="/images/TargetSource.png" alt="TargetSource"></p>
<p>spring 中最常用的是 SingletonTargetSource，该类只对 target 进行简单的封装，没有特殊的逻辑。spring AOP 框架默认为需要进行增强的类创建 SingletonTargetSource 实例，所以在日常使用 spring 中我们并不能感觉到 TargetSource 的存在。手动使用 SingletonTargetSource 示例如下所示，可以看出使用 SingletonTargetSource 和直接代理 testBean 在效果上并无不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSingletonTargetSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TestBean</span> <span class="variable">testBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;testBean&quot;</span>);</span><br><span class="line">    <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(testBean);</span><br><span class="line">    <span class="type">TestBean</span> <span class="variable">proxy</span> <span class="operator">=</span> (TestBean) ProxyFactory.getProxy(targetSource);</span><br><span class="line">    assertThat(testBean.getName()).isSameAs(proxy.getName());</span><br><span class="line">    assertThat(testBean).isNotEqualTo(proxy).isNotSameAs(proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TargetSource 接口具体定义及如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetSource</span> <span class="keyword">extends</span> <span class="title class_">TargetClassAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 target 的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getTargetClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 getTarget() 方法每次返回相同的对象，则返回true。</span></span><br><span class="line"><span class="comment">     * 此时不必调用 releaseTarget(Object) 释放对象且 AOP 框架可以对 getTarget() 的结果进行缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isStatic</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 target，用于 AOP framework 反射调用 target 执行方法前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Object <span class="title function_">getTarget</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放获取的 target</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">releaseTarget</span><span class="params">(Object target)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读源码</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>TargetSource</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot SPI 机制探究</title>
    <url>/2023/04/01/spring-spi/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring Boot 带给我们的一大便利是当需要引入一个第三方依赖时，如果其有 Starter，可以加入 Starter 依赖，就可以实现自动装配，这中便利就来自 Spring Boot 独特的 SPI 机制。</p>
<span id="more"></span>

<p>比如项目中希望引入 Mybatis，只需在 POM 中加入以下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>剩下的工作就是定义 Mapper 并使用，中间所有繁杂的配置 Starter 都帮忙做了。如此神奇的功能其实实现原理十分简单，下文进行分析。</p>
<h2 id="获取配置类的全限定名"><a href="#获取配置类的全限定名" class="headerlink" title="获取配置类的全限定名"></a>获取配置类的全限定名</h2><p>从 <code>@SpringBootApplication</code> 注解一路向下寻找，依次找<code>@EnableAutoConfiguration</code>、<code>@Import(AutoConfigurationImportSelector.class)</code>、<code>getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)</code>，可以看到熟悉的 <code>spring.factories</code>，此处调用的两个函数即为 Spring SPI 的扫描逻辑，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; configurations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">		SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));</span><br><span class="line">ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line">		<span class="string">&quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you &quot;</span></span><br><span class="line">				+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a><code>META-INF/spring.factories</code></h3><p>第一种方式是读取 classpath 中的所有 <code>META-INF/spring.factories</code> 文件，此处有三个循环，第一层遍历获取到的文件位置，第二层遍历文件中的属性，第三层遍历每个属性用 <code>,</code> 分割后的字符串（类路径），这样就获取到了所有需要进行装配的 Configuration 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">	<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">	<span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">	<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">		String[] factoryImplementationNames =</span><br><span class="line">				StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">		<span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">			result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">					.add(factoryImplementationName.trim());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="META-INF-spring-org-springframework-boot-autoconfigure-AutoConfiguration-imports"><a href="#META-INF-spring-org-springframework-boot-autoconfigure-AutoConfiguration-imports" class="headerlink" title="META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports"></a><code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></h3><p>在 Spring Boot 2.7.0 中，增加了对另一种自动配置方式的支持，即读取资源文件 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件，第一层遍历获取到的文件位置，第二层遍历文件中的行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> String.format(LOCATION, annotation.getName());</span><br><span class="line">Enumeration&lt;URL&gt; urls = findUrlsInClasspath(classLoaderToUse, location);</span><br><span class="line">List&lt;String&gt; importCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">	<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">	importCandidates.addAll(readCandidateConfigurations(url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>得到类名后，Spring 利用 <code>Class.forName</code> 将所有需要进行装配的配置类进行加载实例化，不再赘述。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习编码的过程中不能被像 SPI 看起来高深的概念所迷惑，看起来很神奇的自动装配功能其实归根到底就是读取特定名称的配置文件，然后反射获取配置类。</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>SPI</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Windows 下愉快地使用 SSH</title>
    <url>/2023/04/01/ssh/</url>
    <content><![CDATA[<p>Windows 现在自带OpenSSH客户端，配合git进行使用</p>
<span id="more"></span>

<h2 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h2><p>使用 <code>Ed25519</code> 算法生成 SSH key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>确认生成路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (C:\Users\you/.ssh/id_ed25519):</span><br></pre></td></tr></table></figure>

<p>输入两次 passphrase，可以为空，为空时一旦有人获取私钥，则可以访问所有配置了该私钥的系统，不建议为空。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line"></span><br><span class="line">Enter same passphrase again:</span><br><span class="line"></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> C:\Users\you/.ssh/id_ed25519</span><br><span class="line"></span><br><span class="line">Your public key has been saved <span class="keyword">in</span> C:\Users\you/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure>

<p>生成后相应目录会产生两个文件，<code>.pub</code>后缀为公钥，另一个为私钥。</p>
<h2 id="使用-SSH-Key"><a href="#使用-SSH-Key" class="headerlink" title="使用 SSH Key"></a>使用 SSH Key</h2><p>使用方式以<code>GitHub</code>为例，进入<code>Settings</code>-&gt;<code>SSH and GPG keys</code>-&gt;<code>New SSH key</code>，将公钥内容粘贴进<code>Key</code>框中，点击<code>Add SSH key</code>，</p>
<p>测试 github 认证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;C:\Users\you/.ssh/id_ed25519&#x27;</span>:</span><br><span class="line"></span><br><span class="line">Hi xxx! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-ssh-agent"><a href="#配置-ssh-agent" class="headerlink" title="配置 ssh-agent"></a>配置 ssh-agent</h2><p>在做完以上步骤后， SHH Key 已经可以正常使用了，但是每次都要输入 passphrase，十分麻烦，可以利用 ssh-agent 对私钥解密结果进行缓存。</p>
<p>使用键盘输入 <code>Win</code> + <code>R</code>，输入<code>services.msc</code>进入服务。打开<code>OpenSSH Authentication Agent</code>项目，启动类型选择自动或自动(延迟启动)，点击启动。</p>
<p>添加 SSH key 到 ssh-agent</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh-add</span><br><span class="line"></span><br><span class="line">Enter passphrase <span class="keyword">for</span> C:\Users\lusha/.ssh/id_ed25519:</span><br><span class="line"></span><br><span class="line">Identity added: C:\Users\you/.ssh/id_ed25519 (your_email@example.com)</span><br></pre></td></tr></table></figure>

<p>操作完成后，删除私钥文件。建议将私钥文件加密备份，以防操作系统重装等因素导致私钥丢失</p>
<h2 id="GPG"><a href="#GPG" class="headerlink" title="GPG"></a>GPG</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --full-generate-key</span><br><span class="line">gpg (GnuPG) 2.2.29-unknown; Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">gpg: directory <span class="string">&#x27;/c/Users/lusha/.gnupg&#x27;</span> created</span><br><span class="line">gpg: keybox <span class="string">&#x27;/c/Users/lusha/.gnupg/pubring.kbx&#x27;</span> created</span><br><span class="line">Please <span class="keyword">select</span> what kind of key you want:</span><br><span class="line">   (1) RSA and RSA (default)</span><br><span class="line">   (2) DSA and Elgamal</span><br><span class="line">   (3) DSA (sign only)</span><br><span class="line">   (4) RSA (sign only)</span><br><span class="line">  (14) Existing key from card</span><br><span class="line">Your selection? 1</span><br><span class="line">RSA keys may be between 1024 and 4096 bits long.</span><br><span class="line">What keysize <span class="keyword">do</span> you want? (3072) 4096</span><br><span class="line">Requested keysize is 4096 bits</span><br><span class="line">Please specify how long the key should be valid.</span><br><span class="line">         0 = key does not expire</span><br><span class="line">      &lt;n&gt;  = key expires <span class="keyword">in</span> n days</span><br><span class="line">      &lt;n&gt;w = key expires <span class="keyword">in</span> n weeks</span><br><span class="line">      &lt;n&gt;m = key expires <span class="keyword">in</span> n months</span><br><span class="line">      &lt;n&gt;y = key expires <span class="keyword">in</span> n years</span><br><span class="line">Key is valid <span class="keyword">for</span>? (0)</span><br><span class="line">Key does not expire at all</span><br><span class="line">Is this correct? (y/N) y</span><br><span class="line"></span><br><span class="line">GnuPG needs to construct a user ID to identify your key.</span><br><span class="line"></span><br><span class="line">Real name: lsq27</span><br><span class="line">Email address: lushaoqiang27@gmail.com</span><br><span class="line">Comment:</span><br><span class="line">You selected this USER-ID:</span><br><span class="line">    <span class="string">&quot;lsq27 &lt;lushaoqiang27@gmail.com&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O</span><br><span class="line">We need to generate a lot of random bytes. It is a good idea to perform</span><br><span class="line">some other action (<span class="built_in">type</span> on the keyboard, move the mouse, utilize the</span><br><span class="line">disks) during the prime generation; this gives the random number</span><br><span class="line">generator a better chance to gain enough entropy.</span><br><span class="line">We need to generate a lot of random bytes. It is a good idea to perform</span><br><span class="line">some other action (<span class="built_in">type</span> on the keyboard, move the mouse, utilize the</span><br><span class="line">disks) during the prime generation; this gives the random number</span><br><span class="line">generator a better chance to gain enough entropy.</span><br><span class="line">gpg: /c/Users/lusha/.gnupg/trustdb.gpg: trustdb created</span><br><span class="line">gpg: key 14F807AABAA53E8E marked as ultimately trusted</span><br><span class="line">gpg: directory <span class="string">&#x27;/c/Users/lusha/.gnupg/openpgp-revocs.d&#x27;</span> created</span><br><span class="line">gpg: revocation certificate stored as <span class="string">&#x27;/c/Users/lusha/.gnupg/openpgp-revocs.d/99A618713B52EF6F70AE461A14F807AABAA53E8E.rev&#x27;</span></span><br><span class="line">public and secret key created and signed.</span><br><span class="line"></span><br><span class="line">pub   rsa4096 2023-03-31 [SC]</span><br><span class="line">      99A618713B52EF6F70AE461A14F807AABAA53E8E</span><br><span class="line">uid                      lsq27 &lt;lushaoqiang27@gmail.com&gt;</span><br><span class="line">sub   rsa4096 2023-03-31 [E]</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>转载请注明出处，使用时须遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0 License</a> 中所述条款。</p>
</blockquote>
<h1 id="在-Windows-下愉快地使用-SSH"><a href="#在-Windows-下愉快地使用-SSH" class="headerlink" title="在 Windows 下愉快地使用 SSH"></a>在 Windows 下愉快地使用 SSH</h1><h2 id="生成-SSH-key-1"><a href="#生成-SSH-key-1" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h2><p>使用 <code>Ed25519</code> 算法生成 SSH key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>确认生成路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (C:\Users\you/.ssh/id_ed25519):</span><br></pre></td></tr></table></figure>

<p>输入两次 passphrase，可以为空，为空时一旦有人获取私钥，则可以访问所有配置了该私钥的系统，不建议为空。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line"></span><br><span class="line">Enter same passphrase again:</span><br><span class="line"></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> C:\Users\you/.ssh/id_ed25519</span><br><span class="line"></span><br><span class="line">Your public key has been saved <span class="keyword">in</span> C:\Users\you/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure>

<p>生成后相应目录会产生两个文件，<code>.pub</code>后缀为公钥，另一个为私钥。</p>
<h2 id="使用-SSH-Key-1"><a href="#使用-SSH-Key-1" class="headerlink" title="使用 SSH Key"></a>使用 SSH Key</h2><p>使用方式以<code>GitHub</code>为例，进入<code>Settings</code>-&gt;<code>SSH and GPG keys</code>-&gt;<code>New SSH key</code>，将公钥内容粘贴进<code>Key</code>框中，点击<code>Add SSH key</code>，</p>
<p>测试 github 认证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;C:\Users\you/.ssh/id_ed25519&#x27;</span>:</span><br><span class="line"></span><br><span class="line">Hi xxx! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-ssh-agent-1"><a href="#配置-ssh-agent-1" class="headerlink" title="配置 ssh-agent"></a>配置 ssh-agent</h2><p>在做完以上步骤后， SHH Key 已经可以正常使用了，但是每次都要输入 passphrase，十分麻烦，可以利用 ssh-agent 对私钥解密结果进行缓存。</p>
<p>使用键盘输入 <code>Win</code> + <code>R</code>，输入<code>services.msc</code>进入服务。打开<code>OpenSSH Authentication Agent</code>项目，启动类型选择自动或自动(延迟启动)，点击启动。</p>
<p>添加 SSH key 到 ssh-agent</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh-add</span><br><span class="line"></span><br><span class="line">Enter passphrase <span class="keyword">for</span> C:\Users\lusha/.ssh/id_ed25519:</span><br><span class="line"></span><br><span class="line">Identity added: C:\Users\you/.ssh/id_ed25519 (your_email@example.com)</span><br></pre></td></tr></table></figure>

<p>操作完成后，删除私钥文件。建议将私钥文件加密备份，以防操作系统重装等因素导致私钥丢失</p>
<h2 id="GPG-1"><a href="#GPG-1" class="headerlink" title="GPG"></a>GPG</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --full-generate-key</span><br><span class="line">gpg (GnuPG) 2.2.29-unknown; Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">gpg: directory <span class="string">&#x27;/c/Users/lusha/.gnupg&#x27;</span> created</span><br><span class="line">gpg: keybox <span class="string">&#x27;/c/Users/lusha/.gnupg/pubring.kbx&#x27;</span> created</span><br><span class="line">Please <span class="keyword">select</span> what kind of key you want:</span><br><span class="line">   (1) RSA and RSA (default)</span><br><span class="line">   (2) DSA and Elgamal</span><br><span class="line">   (3) DSA (sign only)</span><br><span class="line">   (4) RSA (sign only)</span><br><span class="line">  (14) Existing key from card</span><br><span class="line">Your selection? 1</span><br><span class="line">RSA keys may be between 1024 and 4096 bits long.</span><br><span class="line">What keysize <span class="keyword">do</span> you want? (3072) 4096</span><br><span class="line">Requested keysize is 4096 bits</span><br><span class="line">Please specify how long the key should be valid.</span><br><span class="line">         0 = key does not expire</span><br><span class="line">      &lt;n&gt;  = key expires <span class="keyword">in</span> n days</span><br><span class="line">      &lt;n&gt;w = key expires <span class="keyword">in</span> n weeks</span><br><span class="line">      &lt;n&gt;m = key expires <span class="keyword">in</span> n months</span><br><span class="line">      &lt;n&gt;y = key expires <span class="keyword">in</span> n years</span><br><span class="line">Key is valid <span class="keyword">for</span>? (0)</span><br><span class="line">Key does not expire at all</span><br><span class="line">Is this correct? (y/N) y</span><br><span class="line"></span><br><span class="line">GnuPG needs to construct a user ID to identify your key.</span><br><span class="line"></span><br><span class="line">Real name: lsq27</span><br><span class="line">Email address: lushaoqiang27@gmail.com</span><br><span class="line">Comment:</span><br><span class="line">You selected this USER-ID:</span><br><span class="line">    <span class="string">&quot;lsq27 &lt;lushaoqiang27@gmail.com&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O</span><br><span class="line">We need to generate a lot of random bytes. It is a good idea to perform</span><br><span class="line">some other action (<span class="built_in">type</span> on the keyboard, move the mouse, utilize the</span><br><span class="line">disks) during the prime generation; this gives the random number</span><br><span class="line">generator a better chance to gain enough entropy.</span><br><span class="line">We need to generate a lot of random bytes. It is a good idea to perform</span><br><span class="line">some other action (<span class="built_in">type</span> on the keyboard, move the mouse, utilize the</span><br><span class="line">disks) during the prime generation; this gives the random number</span><br><span class="line">generator a better chance to gain enough entropy.</span><br><span class="line">gpg: /c/Users/lusha/.gnupg/trustdb.gpg: trustdb created</span><br><span class="line">gpg: key 14F807AABAA53E8E marked as ultimately trusted</span><br><span class="line">gpg: directory <span class="string">&#x27;/c/Users/lusha/.gnupg/openpgp-revocs.d&#x27;</span> created</span><br><span class="line">gpg: revocation certificate stored as <span class="string">&#x27;/c/Users/lusha/.gnupg/openpgp-revocs.d/99A618713B52EF6F70AE461A14F807AABAA53E8E.rev&#x27;</span></span><br><span class="line">public and secret key created and signed.</span><br><span class="line"></span><br><span class="line">pub   rsa4096 2023-03-31 [SC]</span><br><span class="line">      99A618713B52EF6F70AE461A14F807AABAA53E8E</span><br><span class="line">uid                      lsq27 &lt;lushaoqiang27@gmail.com&gt;</span><br><span class="line">sub   rsa4096 2023-03-31 [E]</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>转载请注明出处，使用时须遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0 License</a> 中所述条款。</p>
</blockquote>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>GPG</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 的三种 IO 模型</title>
    <url>/2023/08/22/tomcat-io/</url>
    <content><![CDATA[<p>在用 Java 手写服务器示例代码的时候有一些疑惑，加之日常开发中只对 Tomcat 有浅显的理解，知道其是用线程池处理请求，所以就翻了翻 Tomcat 的源代码。本文记录 Tomcat 中 IO 模型的相关代码，版本为 tomcat-embed-core:9.0.78。</p>
<span id="more"></span>

<p>Tomcat 支持的 IO 模型有 APR、NIO、NIO2 三种。</p>
<p>APR、NIO 两种实现方式本质上都是 reactor 模式，使用 IO 多路复用和线程池实现并发处理多个客户端请求。使用的是主从 reactor 多线程模型。其中 acceptor 为主 reactor，负责接受新连接。poller 为从 reactor，负责监控 IO 事件，worker 为执行 IO 操作和业务代码的线程池。</p>
<h2 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h2><p>Tomcat 中封装 IO 相关方法的类叫做 endpoint，负责创建 acceptor, poller, worker 等对象，并负责这几个类之间的交互，作用是胶水代码。<br>抽象类为 AbstractEndpoint，具体的子类有 AprEndpoint、NioEndpoint 和 Nio2Endpoint，分别代表 APR、NIO 和 NIO2 三种 IO 模型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEndpoint</span>&lt;S,U&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * endpoint 的入口，用于启动 acceptor, poller, worker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 worker 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        internalExecutor = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (getUseVirtualThreads()) &#123;</span><br><span class="line">            <span class="comment">// 创建 Java 21 虚拟线程池</span></span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">VirtualThreadExecutor</span>(getName() + <span class="string">&quot;-virt-&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建多线程线程池，默认核心线程数 10，最大线程数 200，优先级 5</span></span><br><span class="line">            <span class="type">TaskQueue</span> <span class="variable">taskqueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">            <span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">            taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并启动 acceptor 线程，APR, NIO 使用该默认实现，NIO2 重写了该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startAcceptorThread</span><span class="params">()</span> &#123;</span><br><span class="line">        acceptor = <span class="keyword">new</span> <span class="title class_">Acceptor</span>&lt;&gt;(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> getName() + <span class="string">&quot;-Acceptor&quot;</span>;</span><br><span class="line">        acceptor.setThreadName(threadName);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(acceptor, threadName);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受连接，被 acceptor 调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> U <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置连接，被 acceptor 调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(U socket)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 socket 事件，被 poller 调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span><br><span class="line"><span class="params">            SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 socket 处理器</span></span><br><span class="line">            SocketProcessorBase&lt;S&gt; sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">            <span class="comment">// 处理 socket 事件，根据 dispatch 判断是否使用 worker 处理</span></span><br><span class="line">            <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getExecutor();</span><br><span class="line">            <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="literal">null</span>) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 socket 处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> SocketProcessorBase&lt;S&gt; <span class="title function_">createSocketProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">            SocketWrapperBase&lt;S&gt; socketWrapper, SocketEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AprEndpoint"><a href="#AprEndpoint" class="headerlink" title="AprEndpoint"></a>AprEndpoint</h3><p>该类将在 Tomcat 10 被废弃，APR 通过 JNI 进行 socket 操作，相比使用 Java IO API 效率更高。<br>使用该类会创建以下线程（池）</p>
<ul>
<li>acceptor 线程</li>
<li>poller 线程</li>
<li>sendfile 线程</li>
<li>worker 线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AprEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractEndpoint</span>&lt;Long,Long&gt; <span class="keyword">implements</span> <span class="title class_">SNICallBack</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">serverSock</span> <span class="operator">=</span> Socket.create(family, Socket.SOCK_STREAM, <span class="number">0</span>, rootPool);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Socket.bind(serverSock, sockAddress);</span><br><span class="line">        ret = Socket.listen(serverSock, getAcceptCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 APR endpoint，启动 acceptor, poller, sendfile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            running = <span class="literal">true</span>;</span><br><span class="line">            paused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 worker 线程池</span></span><br><span class="line">            <span class="keyword">if</span> (getExecutor() == <span class="literal">null</span>) &#123;</span><br><span class="line">                createExecutor();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 poller 线程</span></span><br><span class="line">            poller = <span class="keyword">new</span> <span class="title class_">Poller</span>();</span><br><span class="line">            poller.init();</span><br><span class="line">            poller.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 sendfile 线程</span></span><br><span class="line">            <span class="keyword">if</span> (getUseSendfile()) &#123;</span><br><span class="line">                sendfile = <span class="keyword">new</span> <span class="title class_">Sendfile</span>();</span><br><span class="line">                sendfile.init();</span><br><span class="line">                sendfile.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 acceptor 线程</span></span><br><span class="line">            startAcceptorThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AprEndpoint 接受连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">socket</span> <span class="operator">=</span> Socket.accept(serverSock);</span><br><span class="line">        <span class="keyword">return</span> Long.valueOf(socket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AprEndpoint 设置连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(Long socket)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">AprSocketWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AprSocketWrapper</span>(socket, <span class="built_in">this</span>);</span><br><span class="line">            connections.put(socket, wrapper);</span><br><span class="line">            wrapper.setKeepAliveLeft(getMaxKeepAliveRequests());</span><br><span class="line">            wrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            wrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            getExecutor().execute(<span class="keyword">new</span> <span class="title class_">SocketWithOptionsProcessor</span>(wrapper));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把socket交给poller处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">SocketWithOptionsProcessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> socket.getLock();</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getPoller().add(socket.getSocket().longValue(), getConnectionTimeout(), Poll.APR_POLLIN);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NioEndpoint"><a href="#NioEndpoint" class="headerlink" title="NioEndpoint"></a>NioEndpoint</h3><p>NioEndpoint 通过 Java NIO 进行同步非阻塞 IO 操作。相比使用同步阻塞 IO，大大减少了高并发下所需线程的数量，因而效率更高。</p>
<p>使用该类会创建以下线程（池）</p>
<ul>
<li>acceptor 线程（阻塞接受新连接）</li>
<li>poller 线程（配置 IO 多路复用，检测 IO 事件）</li>
<li>worker 线程池（处理 IO 事件）</li>
</ul>
<p>acceptor 循环接受连接并将注册事件放入 poller 的事件队列，poller 循环处理事件队列中的事件并检测 IO 事件，如果发生 IO 事件让 worker 进行 IO 操作并执行业务代码。</p>
<p>功能示意图如下</p>
<p><img src="/../images/NIO.png" alt="NIO"></p>
<p>向服务器发出一个请求，查看线程状态。编号 1-10 的线程为 worker 线程。</p>
<p><img src="/../images/NIO%E7%BA%BF%E7%A8%8B.png" alt="NIO thread"></p>
<p>收到请求后，一个 worker 线程由 Park 状态转为 Running 状态；接着服务器访问外部服务，等待 IO 期间线程转为 Wait 状态；访问外部服务完成后整个请求结束，线程又转为 Park 状态。</p>
<p>NIO 相关代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel,SocketChannel&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getAddress(), getPortWithOffset());</span><br><span class="line">        serverSock.bind(addr, getAcceptCount());</span><br><span class="line">        serverSock.configureBlocking(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 NIO endpoint，启动 acceptor, poller</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            running = <span class="literal">true</span>;</span><br><span class="line">            paused = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 创建 worker 线程池</span></span><br><span class="line">            <span class="keyword">if</span> (getExecutor() == <span class="literal">null</span>) &#123;</span><br><span class="line">                createExecutor();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动 poller 线程</span></span><br><span class="line">            poller = <span class="keyword">new</span> <span class="title class_">Poller</span>();</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">pollerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(poller, getName() + <span class="string">&quot;-Poller&quot;</span>);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">            <span class="comment">// 启动 acceptor 线程</span></span><br><span class="line">            startAcceptorThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NioEndpoint 接受连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SocketChannel <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 阻塞接受连接</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">result</span> <span class="operator">=</span> serverSock.accept();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NioEndpoint 设置连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(SocketChannel socket)</span> &#123;</span><br><span class="line">        <span class="type">NioSocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketBufferHandler</span> <span class="variable">bufhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketBufferHandler</span>(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="type">NioChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioChannel</span>(bufhandler);</span><br><span class="line">            <span class="type">NioSocketWrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioSocketWrapper</span>(channel, <span class="built_in">this</span>);</span><br><span class="line">            channel.reset(socket, newWrapper);</span><br><span class="line">            connections.put(socket, newWrapper);</span><br><span class="line">            socketWrapper = newWrapper;</span><br><span class="line">            <span class="comment">// 因使用 IO 多路复用，设置为非阻塞 IO</span></span><br><span class="line">            socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (getUnixDomainSocketPath() == <span class="literal">null</span>) &#123;</span><br><span class="line">                socketProperties.setProperties(socket.socket());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            socketWrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setKeepAliveLeft(NioEndpoint.<span class="built_in">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">            <span class="comment">// 将 socket 注册到 poller</span></span><br><span class="line">            poller.register(socketWrapper);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nio2Endpoint"><a href="#Nio2Endpoint" class="headerlink" title="Nio2Endpoint"></a>Nio2Endpoint</h3><p>Nio2Endpoint 通过 Java NIO 进行异步 IO 操作，相比使用同步非阻塞 IO，应用不需将数据拷贝到进程中，而由内核代为完成后通知应用，执行回调。Java 异步 IO 在 Windows 中通过 IOCP 实现，在 Linux 中通过 epoll 模拟实现，所以理论上在 Linux 下同步非阻塞 IO 和异步 IO 的效率无明显差别。</p>
<p>使用该类会创建以下线程（池）</p>
<ul>
<li>acceptor 线程</li>
<li>worker 线程池</li>
</ul>
<p>相比同步非阻塞 IO，少了 poller，操作系统承担了 poller 的工作和。</p>
<p>功能示意图如下</p>
<p><img src="/../images/NIO2.png" alt="NIO2"></p>
<p>向服务器发出一个请求，查看线程状态。编号 1-10 的线程为 worker 线程。</p>
<p><img src="/../images/NIO2%E7%BA%BF%E7%A8%8B.png" alt="NIO2 thread"></p>
<p>收到请求后，一个 worker 线程由 Park 状态转为 Running 状态；接着服务器访问外部服务，等待 IO 期间线程转为 Wait 状态；访问外部服务完成后整个请求结束，线程又转为 Park 状态。</p>
<p>NIO2 相关代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO2 endpoint.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nio2Endpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;Nio2Channel,AsynchronousSocketChannel&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 使用 worker 线程池处理 IO 事件</span></span><br><span class="line">        threadGroup = AsynchronousChannelGroup.withThreadPool((ExecutorService) getExecutor());</span><br><span class="line">        serverSock = AsynchronousServerSocketChannel.open(threadGroup);</span><br><span class="line">        socketProperties.setProperties(serverSock);</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getAddress(), getPortWithOffset());</span><br><span class="line">        <span class="comment">// 绑定地址</span></span><br><span class="line">        serverSock.bind(addr, getAcceptCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 NIO2 endpoint, 启动 acceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建 worker 线程池</span></span><br><span class="line">        <span class="keyword">if</span> (getExecutor() == <span class="literal">null</span>) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动 acceptor 线程</span></span><br><span class="line">        startAcceptorThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 NIO2 acceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startAcceptorThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">            acceptor = <span class="keyword">new</span> <span class="title class_">Nio2Acceptor</span>(<span class="built_in">this</span>);</span><br><span class="line">            acceptor.setThreadName(getName() + <span class="string">&quot;-Acceptor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 worker 线程池启动 accepor</span></span><br><span class="line">        getExecutor().execute(acceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞接受连接，该方法未被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AsynchronousSocketChannel <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AsynchronousSocketChannel</span> <span class="variable">result</span> <span class="operator">=</span> serverSock.accept().get();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Nio2Endpoint 设置连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(AsynchronousSocketChannel socket)</span> &#123;</span><br><span class="line">        <span class="type">Nio2SocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketBufferHandler</span> <span class="variable">bufhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketBufferHandler</span>(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="type">Nio2Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Nio2Channel</span>(bufhandler);</span><br><span class="line">            <span class="type">Nio2SocketWrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Nio2SocketWrapper</span>(channel, <span class="built_in">this</span>);</span><br><span class="line">            channel.reset(socket, newWrapper);</span><br><span class="line">            connections.put(socket, newWrapper);</span><br><span class="line">            socketWrapper = newWrapper;</span><br><span class="line"></span><br><span class="line">            socketProperties.setProperties(socket);</span><br><span class="line">            socketWrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setKeepAliveLeft(Nio2Endpoint.<span class="built_in">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">            <span class="comment">// 调用 AbstractEndpoint.processSocket 方法处理 IO 事件。因为是异步 IO，所以不需要使用新线程处理 IO 事件</span></span><br><span class="line">            <span class="keyword">return</span> processSocket(socketWrapper, SocketEvent.OPEN_READ, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">SocketProcessor</span> <span class="keyword">extends</span> <span class="title class_">SocketProcessorBase</span>&lt;Nio2Channel&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被 AbstractEndpoint.processSocket 调用，处理 IO 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">launch</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketState</span> <span class="variable">state</span> <span class="operator">=</span> SocketState.OPEN;</span><br><span class="line">            <span class="comment">// 处理 IO 事件</span></span><br><span class="line">            <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">                state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = getHandler().process(socketWrapper, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (state == SocketState.UPGRADING) &#123;</span><br><span class="line">                launch = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (launch) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 使用新线程处理 IO 事件</span></span><br><span class="line">                    getExecutor().execute(<span class="keyword">new</span> <span class="title class_">SocketProcessor</span>(socketWrapper, SocketEvent.OPEN_READ));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h2><p>acceptor 的功能如其名称，用于接受 socket 连接请求。产生一个与客户端的连接的 socket 后，再将其交给 poller 处理。<br>acceptor 的代码逻辑特别简单，不断地调用 <code>endpoint.serverSocketAccept</code> 产生 socket 连接，调用 <code>endpoint.setSocketOptions</code> 设置 socket。</p>
<h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h3><p>NIO、APR 的 acceptor 为类 Acceptor，Acceptor 主要代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span>&lt;U&gt; <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线程中循环接受新连接直到收到关闭命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">errorDelay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stopCalled) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 接受连接</span></span><br><span class="line">                <span class="type">U</span> <span class="variable">socket</span> <span class="operator">=</span> endpoint.serverSocketAccept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</span><br><span class="line">                <span class="comment">// 连接失败进行延时操作</span></span><br><span class="line">                errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// endpoint 设置连接，处理失败则关闭连接</span></span><br><span class="line">            <span class="keyword">if</span> (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                endpoint.closeSocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时时长指数增加，防止短时间内产生大量错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_ERROR_DELAY</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ERROR_DELAY</span> <span class="operator">=</span> <span class="number">1600</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">handleExceptionWithDelay</span><span class="params">(<span class="type">int</span> currentErrorDelay)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次不延时</span></span><br><span class="line">        <span class="keyword">if</span> (currentErrorDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Thread.sleep(currentErrorDelay);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentErrorDelay == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INITIAL_ERROR_DELAY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentErrorDelay &lt; MAX_ERROR_DELAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentErrorDelay * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MAX_ERROR_DELAY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nio2Acceptor"><a href="#Nio2Acceptor" class="headerlink" title="Nio2Acceptor"></a>Nio2Acceptor</h3><p>NIO2 中的 acceptor 为类 Nio2Acceptor，Nio2Acceptor 重写了 Acceptor 的 <code>run</code> 方法，用异步 IO 替代同步 IO。且实现了 CompletionHandler 接口，用于处理异步 IO 完成事件。</p>
<p>Nio2Acceptor 的主要代码如下，其中没有调用 <code>endpoint.serverSocketAccept</code> 产生 socket，而是直接调用 <code>serverSock.accept</code> 产生 socket，另一个异同是 Nio2Acceptor 的 run 方法中没有循环，而是通过异步 IO 的回调函数重新接受新请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Nio2Acceptor</span> <span class="keyword">extends</span> <span class="title class_">Acceptor</span>&lt;AsynchronousSocketChannel&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果达到最大连接数，等待</span></span><br><span class="line">        countUpOrAwaitConnection();</span><br><span class="line">        <span class="comment">// 异步 IO，连接完成后由 completed 方法处理，失败由 failed 方法处理</span></span><br><span class="line">        serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接请求成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socket,</span></span><br><span class="line"><span class="params">            Void attachment)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步接受新请求</span></span><br><span class="line">        <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;</span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getConnectionCount() &lt; getMaxConnections()) &#123;</span><br><span class="line">            countUpOrAwaitConnection();</span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 达到最大连接数，使用新线程接受请求</span></span><br><span class="line">            getExecutor().execute(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 socket</span></span><br><span class="line">        <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">            closeSocket(socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接请求失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable t, Void attachment)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;</span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用新线程接受请求</span></span><br><span class="line">            getExecutor().execute(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownConnection();</span><br><span class="line">        <span class="comment">// 失败后等待一段事件</span></span><br><span class="line">        errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poller"><a href="#poller" class="headerlink" title="poller"></a>poller</h2><p>poller 的作用是将新 socket 注册到 selector 并轮询是否有 IO 事件发生。</p>
<h3 id="APR-poller"><a href="#APR-poller" class="headerlink" title="APR poller"></a>APR poller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        pollerThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(poller, getName() + <span class="string">&quot;-Poller&quot;</span>);</span><br><span class="line">        pollerThread.setPriority(threadPriority);</span><br><span class="line">        pollerThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        pollerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SocketList</span> <span class="variable">localAddList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketList</span>(getMaxConnections());</span><br><span class="line">        <span class="keyword">while</span> (pollerRunning) &#123;</span><br><span class="line">            <span class="type">SocketInfo</span> <span class="variable">info</span> <span class="operator">=</span> localAddList.get();</span><br><span class="line">            <span class="keyword">while</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// poll 操作</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rv</span> <span class="operator">=</span> Poll.poll(aprPoller, pollTime, desc, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; rv; n++) &#123;</span><br><span class="line">                    processSocket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NIO-poller"><a href="#NIO-poller" class="headerlink" title="NIO poller"></a>NIO poller</h3><p>poller 负责两件事，处理 poller 事件，处理 IO 事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">wakeupCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// IO 多路复用选择器</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">// poller 事件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronizedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 socket 的读事件注册到事件队列中，被 acceptor 调用 setSocketOptions 时间接调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> NioSocketWrapper socketWrapper)</span> &#123;</span><br><span class="line">        socketWrapper.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        <span class="type">PollerEvent</span> <span class="variable">pollerEvent</span> <span class="operator">=</span> createPollerEvent(socketWrapper, OP_REGISTER);</span><br><span class="line">        addEvent(pollerEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEvent</span><span class="params">(PollerEvent event)</span> &#123;</span><br><span class="line">        events.offer(event);</span><br><span class="line">        <span class="comment">// wakeupCounter 为 -1 时唤醒 selector，处理新事件</span></span><br><span class="line">        <span class="keyword">if</span> (wakeupCounter.incrementAndGet() == <span class="number">0</span>) &#123;</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环处理 poller 事件和 IO 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasEvents</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hasEvents = events();</span><br><span class="line">                <span class="comment">// 事件队列有新事件，wakeupCounter 为 -1 时，selector 正在进行 select 操作</span></span><br><span class="line">                <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 检查有没有 IO，有 IO 先处理 IO</span></span><br><span class="line">                    keyCount = selector.selectNow();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有新事件就等待已注册 IO 的，默认超时 1000ms</span></span><br><span class="line">                    keyCount = selector.select(selectorTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 没有 socket 可读写</span></span><br><span class="line">                <span class="keyword">if</span> (keyCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    hasEvents = (hasEvents | events());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历 selector key，处理 IO 事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (iterator != <span class="literal">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="type">NioSocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> (NioSocketWrapper) sk.attachment();</span><br><span class="line">                processKey(sk, socketWrapper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理超时的连接</span></span><br><span class="line">            timeout(keyCount,hasEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        getStopLatch().countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 poller 事件队列中的事件，如果处理了事件返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">events</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PollerEvent</span> <span class="variable">pe</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != <span class="literal">null</span>; i++ ) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">NioSocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> pe.getSocketWrapper();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> socketWrapper.getSocket().getIOChannel();</span><br><span class="line">            <span class="comment">// 注册读事件到 selector</span></span><br><span class="line">            sc.register(getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 IO 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper socketWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sk.isReadable() || sk.isWritable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (socketWrapper.getSendfileData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                processSendfile(sk, socketWrapper, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 先读再写</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    processSocket(socketWrapper, SocketEvent.OPEN_READ, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sk.isWritable()) &#123;</span><br><span class="line">                    processSocket(socketWrapper, SocketEvent.OPEN_WRITE, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AprEndpoint-1"><a href="#AprEndpoint-1" class="headerlink" title="AprEndpoint"></a>AprEndpoint</h3><p>跟 NioEndpoint 一样，AprEndpoint 也实现了非阻塞 I&#x2F;O，它们的区别是：NioEndpoint 通过调用 Java 的 NIO API 来实现非阻塞 I&#x2F;O，而 AprEndpoint 是通过 JNI 调用 APR 本地库而实现非阻塞 I&#x2F;O 的。在某些场景下，比如需要频繁与操作系统进行交互，Socket 网络通信就是这样一个场景， 特别是如果你的 Web 应用使用了 TLS 来加密传输，我们知道 TLS 协议在握手过程中有多 次网络交互，在这种情况下 Java 跟 C 语言程序相比还是有一定的差距，而这正是 APR 的 强项。Tomcat 本身是 Java 编写的，为了调用 C 语言编写的 APR，需要通过 JNI 方式来调用。 JNI（Java Native Interface） 是 JDK 提供的一个编程接口，它允许 Java 程序调用其他语 言编写的程序或者代码库，其实 JDK 本身的实现也大量用到 JNI 技术来调用本地 C 程序 库。</p>
<p>它跟 NioEndpoint 的工作原理很像，有 LimitLatch、Acceptor、Poller、 SocketProcessor 和 Http11Processor，只是 Acceptor 和 Poller 的实现和 NioEndpoint 不同。</p>
<p>Acceptor 接收到一个新的 Socket 连接后，按照 NioEndpoint 的实现，它会把这个 Socket 交给 Poller 去查询 I&#x2F;O 事件。AprEndpoint 也是这样做的，不过 AprEndpoint 的 Poller 并不是调用 Java NIO 里的 Selector 来查询 Socket 的状态，而是通过 JNI 调用 APR 中的 poll 方法，而 APR 又是调用了操作系统的 epoll API 来实现的。在 AprEndpoint 中，我们可以配置一个叫 deferAccept 的参数，它对应的是 TCP 协议中的 TCP_DEFER_ACCEPT，设置这个参数后，当 TCP 客户端有新的连接请求到达时，TCP 服务端先不建立连接，而是再等等，直到客户端有请求数据发过来时再建立连接。这样的好处是服务端不需要用 Selector 去反复查询请求数据是否就绪。这是一种 TCP 协议层的优化，不是每个操作系统内核都支持，因为 Java 作为一种跨平台语言，需要屏蔽各种操作系统的差异，因此并没有把这个参数提供给用户；但是对于 APR 来说，它的目的就是尽可能提升性能，因此它向用户暴露了这个参数。</p>
<h3 id="Nio2Endpoint-1"><a href="#Nio2Endpoint-1" class="headerlink" title="Nio2Endpoint"></a>Nio2Endpoint</h3><p>接口，</p>
<p>Accpetor 的功能就是监听连接，接收并建立连接。它的本质就是调用了四个操作系统 API：socket、bind、listen 和 accept。那 Java 语言如何直接调用 C 语言 API 呢？答案 就是通过 JNI。</p>
<p>其中两个重要组件：Acceptor 和 SocketProcessor。</p>
<p>Acceptor 用于监听 Socket 连接请求，SocketProcessor 用于处理收到的 Socket 请求，提交到线程池 Executor 处理。</p>
]]></content>
  </entry>
  <entry>
    <title>使用MSYS2</title>
    <url>/2023/04/08/use-msys2/</url>
    <content><![CDATA[<h2 id="MSYS2-是什么"><a href="#MSYS2-是什么" class="headerlink" title="MSYS2 是什么"></a>MSYS2 是什么</h2><p>来自官网的介绍</p>
<blockquote>
<p>MSYS2 是工具和库的集合，为您提供易于使用的环境，用于构建、安装和运行原生 Windows 软件。</p>
</blockquote>
<p>它由 <a href="https://mintty.github.io/">mintty</a> terminal，bash shell，和一些基于 <a href="https://cygwin.com/">Cygwin</a> 的工具组成。<br>MSYS2 可以为 Windows 提供最新的 GCC、mingw-w64、 CPython，CMake，Meson，OpenSSL，FFmpeg，Rust，Ruby 等软件最新的原生构建。</p>
<p>他的包管理工具是来自 Arch Linux 的 <a href="https://wiki.archlinux.org/index.php/pacman">Pacman</a>，现有约 2800 个软件。</p>
<h2 id="MSYS2-为什么要用-MSYS2"><a href="#MSYS2-为什么要用-MSYS2" class="headerlink" title="MSYS2 为什么要用 MSYS2"></a>MSYS2 为什么要用 MSYS2</h2><p>我最开始用 MSYS2 的目的很简单，需要在 Windows 下编译 C++，不喜欢 MSVC 的臃肿于是选择了 <a href="https://www.mingw-w64.org/">MinGW-w64</a>，MinGW-w64 的下载页中是 Windows 平台且提供的软件较多的两个安装包分别是 Cygwin 和 MSYS2。比较了一番他们的区别之后，我选择了提供原生 Windows 构建工具的 MSYS2。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="安装-MSYS2"><a href="#安装-MSYS2" class="headerlink" title="安装 MSYS2"></a>安装 MSYS2</h3><p>使用 Scoop 、 Winget 或<a href="https://www.msys2.org/">官网</a>安装包</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install msys2</span><br><span class="line">&gt; winget install MSYS2.MSYS2</span><br></pre></td></tr></table></figure>

<h3 id="更新-MSYS2"><a href="#更新-MSYS2" class="headerlink" title="更新 MSYS2"></a>更新 MSYS2</h3><p>启动 UCRT64，更新包，执行 <code>pacman -Syuu</code> 多次直到提示无更新可用。</p>
<h3 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h3><p>搜索可用软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pacman -Ss &lt;name_pattern&gt;</span><br></pre></td></tr></table></figure>

<h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>安装软件包或一组软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pacman -S &lt;package_names|package_groups&gt;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>列出显示安装过的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacman -Qe</span><br></pre></td></tr></table></figure>

<h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><p>卸载软件包或一组软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pacman -R &lt;package_names|package_groups&gt;</span><br></pre></td></tr></table></figure>

<h2 id="开发配置"><a href="#开发配置" class="headerlink" title="开发配置"></a>开发配置</h2><h3 id="安装工具链"><a href="#安装工具链" class="headerlink" title="安装工具链"></a>安装工具链</h3><p>安装 MSYS2 最大的目的就是 GCC 工具链，其中有两个软件包组需要安装</p>
<ul>
<li><a href="https://packages.msys2.org/package/base-devel?repo=msys&variant=x86_64">base-devel</a> 包含 make，curl，grep 等开发常用的基础包</li>
<li><a href="https://packages.msys2.org/groups/mingw-w64-ucrt-x86_64-toolchain">mingw-w64-ucrt-x86_64-toolchain</a> 包含 GCC 工具链</li>
</ul>
<p>和 Linux 相似，<code>devel</code> 结尾的包，包含使用该程序进行开发的所有的必需文件，例如 libcurl-devel 中包含 Libcurl 的头文件和库文件</p>
<p><code>msys repo</code> 下的包会被安装到 <code>/usr</code> 目录下，<code>ucrt64 repo</code> 下的包会被安装到 <code>/ucrt64</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain</span><br></pre></td></tr></table></figure>

<h3 id="更换-shell"><a href="#更换-shell" class="headerlink" title="更换 shell"></a>更换 shell</h3><p>MSYS2 默认为 Bash，个人更喜欢 Fish。安装配置方式与 Linux 下相同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pacman -S fish</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/msys2_shell.cmd -defterm -here -no-start -ucrt64 -shell fish</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：更换 shell 后如果还需运行 Bash 脚本，请在 Bash 脚本第一行添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S mingw-w64-ucrt-x86_64-oh-my-posh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano ~/.config/fish/config.fish</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">oh-my-posh init fish --config /ucrt64/share/oh-my-posh/themes/1_shell.omp.json | <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>MSYS2 带有不同的环境&#x2F;子系统，您拥有的第一件事 决定使用哪一个。环境之间的差异是 主要是环境变量、默认编译器&#x2F;链接器、架构、 使用的系统库等如果您不确定，请选择 UCRT64。</p>
<p>MSYS 环境包含基于 unix&#x2F;cygwin 的工具，存在于其下，并且特别之处在于它始终处于活动状态。所有其他环境 从 MSYS 环境继承并在其上添加各种内容。&#x2F;usr</p>
<p>例如，在 UCRT64 环境中，变量以 因此您可以获得所有基于 ucrt64 的工具以及所有 msys 工具。<code>$PATH=/ucrt64/bin:/usr/bin</code></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>package manager</tag>
        <tag>Scoop</tag>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title>增强 Windows 开发体验</title>
    <url>/2023/04/09/use-powershell/</url>
    <content><![CDATA[<p>Windows 的终端相比于 Unix-Like 来说，一直处于弱势。微软注意到了这个问题，在尝试增强 Windows 下的开发体验。最近正好重装了笔记本的操作系统</p>
<p>一般来说，PowerShell 中用户创建的变量、函数等只能在当前的窗口会话生效。但配置文件非常特殊，PowerShell 每次启动前都会加载该文件。如果将某些命令写入这个文件，修改就能全局生效。新建或修改配置文件最简单的方法是输入 notepad $profile，在弹出的编辑窗口添加命令即可。</p>
<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>个人喜欢的包管理工具是 <a href="https://scoop.sh/">Scoop</a>，主打便携功能当然 Chocolate 和 Winget 也是不错的选择。</p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="Nerd-Fonts"><a href="#Nerd-Fonts" class="headerlink" title="Nerd Fonts"></a>Nerd Fonts</h3><p>安装 一款 <a href="https://github.com/ryanoasis/nerd-fonts">Nerd Fonts</a>，推荐 <code>Fira Code Nerd Font</code>，<code>Fira Code</code> 支持连字 <code>ligature</code>，<code>Nerd Fonts</code> 在原有字体的基础上增加了图标字符。</p>
<h3 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h3><p>安装最新版 <a href="https://www.microsoft.com/store/productId/9MZ1SNWT0N5D">PowerShell 7.3.3</a></p>
<h3 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h3><p>安装最新版 <a href="https://www.microsoft.com/store/productId/9N0DX20HK701">Windows Terminal 1.15</a></p>
<ul>
<li>将 <code>PowerShell</code> 设置为默认配置文件<br><img src="/images/1.png" alt="PowerShell"></li>
<li>将 <code>Fira Code NF</code> 设置为默认字体<br><img src="/images/2.png" alt="PowerShell"></li>
</ul>
<h2 id="PowerShell-1"><a href="#PowerShell-1" class="headerlink" title="PowerShell"></a>PowerShell</h2><p><a href="https://github.com/PowerShell/PSReadLine">PSReadLine</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-PSReadLineOption</span> <span class="literal">-PredictionViewStyle</span> ListView</span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> Tab <span class="literal">-Function</span> MenuComplete</span><br><span class="line">scoop install scoop<span class="literal">-completion</span></span><br></pre></td></tr></table></figure>

<h2 id="利用别名缩短命令"><a href="#利用别名缩短命令" class="headerlink" title="利用别名缩短命令"></a>利用别名缩短命令</h2><p>获取别名</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">Get-Alias</span> name</span><br></pre></td></tr></table></figure>

<p>获取别名</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">Get-Alias</span> name</span><br></pre></td></tr></table></figure>

<p>设置别名</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">Set-Alias</span> alias command</span><br></pre></td></tr></table></figure>

<p>移除别名</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">Remove-Alias</span> name</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>package manager</tag>
        <tag>Scoop</tag>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 下最好的便携式包管理工具 - Scoop</title>
    <url>/2022/02/07/use-scoop/</url>
    <content><![CDATA[<h2 id="Scoop-是什么"><a href="#Scoop-是什么" class="headerlink" title="Scoop 是什么"></a>Scoop 是什么</h2><p><a href="https://scoop.sh/">Scoop</a>是一个 Windows 下的命令行安装器，可以用来解决应用及其依赖下载、安装、更新、卸载。其官网的自我介绍是</p>
<blockquote>
<p>Scoop 以阻力最小的方式从命令行安装您熟悉和喜爱的程序，它可以：</p>
<ul>
<li>消除权限弹出窗口</li>
<li>隐藏安装程序的界面</li>
<li>防止安装大量程序对 PATH 的污染</li>
<li>避免安装和卸载程序的意外副作用</li>
<li>查找并安装依赖项</li>
<li>执行所有额外的程序设置步骤</li>
</ul>
</blockquote>
<h2 id="为什么要用-Scoop"><a href="#为什么要用-Scoop" class="headerlink" title="为什么要用 Scoop"></a>为什么要用 Scoop</h2><p>相比于使用传统的安装包安装，控制面板卸载方式，像 Scoop 这样包管理软件的优势是统一应用管理入口，便于搜索应用，使用应用默认安装方式，统一应用安装路径。对于普通用户可能帮助不大，但是对于经常升级折腾的开发人员来说，一键安装升级卸载的诱惑不可谓不大:)</p>
<p>以前我要安装一个软件，我会</p>
<ul>
<li>搜索引擎搜索 node</li>
<li>打开官网 (注意避开广告！)</li>
<li>寻找适合版本的下载链接，使用下载工具下载</li>
<li>打开安装包配置我需要的参数并安装</li>
</ul>
<p>通过 Scoop 安装一个软件的，只需输入一个命令，Scoop 帮我们</p>
<ul>
<li>下载安装包(压缩包)</li>
<li>安装(解压)</li>
<li>链接安装目录</li>
<li>持久化文件</li>
<li>执行脚本</li>
</ul>
<p>Scoop 不只帮我们省略了找到安装包的过程，还免去了安装时的配置过程(Scoop 在安装脚本中写明了最佳的安装配置)，更妙的是全程都没用到管理员权限，自然也不必担心安装包对操作系统未知的修改(比如偷偷装个证书，设置自己为开机启动)。</p>
<p>和自行安装软件相比，我认为 Scoop 的优点有</p>
<ul>
<li>软件数量多，官方桶中包含约 4000 个软件，第三方桶也有丰富应用</li>
<li>安装不依赖管理员权限，除了极少数特殊软件需要修改注册表或者安装到管理员目录</li>
<li>自动配置，安装时采用默认配置，Scoop 默认把路径设置为自己的目录，开机自启动等设置为否，简化安装步骤</li>
<li>自动安装依赖</li>
<li>自动添加命令行程序的链接到 <code>~/scoop/shims</code>，然后再将该目录添加到环境变量，自动添加 GUI 程序的快捷方式到开始菜单</li>
<li>比 Linux 的包管理工具更便携的软件管理体验，即使重装系统也能快速恢复软件环境</li>
<li>路径可控，大部分文件都会存在于 <code>~/scoop</code>，升级时需要保留的文件存在于 <code>~/scoop/persist</code></li>
</ul>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="安装-Scoop"><a href="#安装-Scoop" class="headerlink" title="安装 Scoop"></a>安装 Scoop</h3><p>打开 PowerShell (版本号大于等于 5.1)，执行以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser <span class="comment"># 获取执行脚本权限</span></span><br><span class="line">&gt; <span class="built_in">irm</span> get.scoop.sh | <span class="built_in">iex</span></span><br><span class="line">&gt; <span class="built_in">irm</span> get.scoop.sh <span class="literal">-Proxy</span> <span class="string">&#x27;http://&lt;ip:port&gt;&#x27;</span> | <span class="built_in">iex</span> <span class="comment"># 使用代理连接 GitHub</span></span><br></pre></td></tr></table></figure>

<p>Scoop 会被安装到 <code>C:\Users\&lt;YOUR USERNAME&gt;\scoop</code> 目录下，如果想自定义安装目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">irm</span> get.scoop.sh <span class="literal">-outfile</span> <span class="string">&#x27;install.ps1&#x27;</span></span><br><span class="line">&gt; .\install.ps1 <span class="literal">-ScoopDir</span> <span class="string">&#x27;D:\Applications\Scoop&#x27;</span> <span class="literal">-ScoopGlobalDir</span> <span class="string">&#x27;F:\GlobalScoopApps&#x27;</span></span><br></pre></td></tr></table></figure>

<p>安装 nodejs-lts</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install nodejs<span class="literal">-lts</span></span><br><span class="line">&gt; node <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>安装 VS Code</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop bucket add extras</span><br><span class="line">&gt; scoop install vscode</span><br></pre></td></tr></table></figure>

<h2 id="管理软件"><a href="#管理软件" class="headerlink" title="管理软件"></a>管理软件</h2><h3 id="搜索软件"><a href="#搜索软件" class="headerlink" title="搜索软件"></a>搜索软件</h3><p>搜索可安装软件，列出所有符合条件的软件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop search name</span><br></pre></td></tr></table></figure>

<h3 id="查看已安装软件"><a href="#查看已安装软件" class="headerlink" title="查看已安装软件"></a>查看已安装软件</h3><p>列出已安装软件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop list</span><br></pre></td></tr></table></figure>

<h3 id="查看软件信息"><a href="#查看软件信息" class="headerlink" title="查看软件信息"></a>查看软件信息</h3><p>查看软件信息，如主页，描述，最后更新时间</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop info name</span><br></pre></td></tr></table></figure>

<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>安装指定名称软件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install name</span><br></pre></td></tr></table></figure>

<h3 id="打印安装路径"><a href="#打印安装路径" class="headerlink" title="打印安装路径"></a>打印安装路径</h3><p>打印指定软件路径</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop prefix name</span><br></pre></td></tr></table></figure>

<h3 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h3><p>更新指定软件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop update name</span><br><span class="line">&gt; scoop update * <span class="comment"># 更新所有软件</span></span><br></pre></td></tr></table></figure>

<h3 id="锁定软件版本"><a href="#锁定软件版本" class="headerlink" title="锁定软件版本"></a>锁定软件版本</h3><p>锁定软件版本，不会被更新</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop hold name</span><br></pre></td></tr></table></figure>

<h3 id="解锁软件版本"><a href="#解锁软件版本" class="headerlink" title="解锁软件版本"></a>解锁软件版本</h3><p>解锁软件版本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop hold name</span><br></pre></td></tr></table></figure>

<h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><p>卸载指定软件，执行卸载脚本(删除环境变量等)</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop uninstall name</span><br></pre></td></tr></table></figure>

<h3 id="清理软件"><a href="#清理软件" class="headerlink" title="清理软件"></a>清理软件</h3><p>软件更新后旧版本并不会被卸载，执行命令进行清理</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop cleanup *</span><br></pre></td></tr></table></figure>

<h2 id="桶管理"><a href="#桶管理" class="headerlink" title="桶管理"></a>桶管理</h2><p>桶(bucket)保存着 Scoop 的可安装软件信息。安装完毕后只有一个桶 - main</p>
<h3 id="搜索桶"><a href="#搜索桶" class="headerlink" title="搜索桶"></a>搜索桶</h3><p>只能在 web 中搜索<a href="https://scoop.sh/#/buckets">可用桶</a></p>
<h3 id="列出官方认证的桶"><a href="#列出官方认证的桶" class="headerlink" title="列出官方认证的桶"></a>列出官方认证的桶</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop bucket known</span><br></pre></td></tr></table></figure>

<h3 id="列出已添加桶"><a href="#列出已添加桶" class="headerlink" title="列出已添加桶"></a>列出已添加桶</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop bucket list</span><br></pre></td></tr></table></figure>

<h3 id="添加桶"><a href="#添加桶" class="headerlink" title="添加桶"></a>添加桶</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop bucket add extras <span class="comment"># 含 GUI 的软件</span></span><br><span class="line">&gt; scoop bucket add versions <span class="comment"># 旧版软件</span></span><br><span class="line">&gt; scoop bucket add nerd<span class="literal">-fonts</span> <span class="comment"># 字体</span></span><br><span class="line">&gt; scoop bucket add nonportable <span class="comment"># 非便携软件</span></span><br><span class="line">&gt; scoop bucket add java <span class="comment"># 各种jdk</span></span><br><span class="line">&gt; scoop bucket add dorado https://github.com/chawyehsu/dorado <span class="comment"># 著名的的中文软件桶</span></span><br></pre></td></tr></table></figure>

<h3 id="删除桶"><a href="#删除桶" class="headerlink" title="删除桶"></a>删除桶</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop bucket <span class="built_in">rm</span> name</span><br></pre></td></tr></table></figure>

<h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><h3 id="优化搜索速度"><a href="#优化搜索速度" class="headerlink" title="优化搜索速度"></a>优化搜索速度</h3><p>scoop 的 search 命令会搜索远程服务器，而 <a href="https://github.com/shilangyu/scoop-search">scoop-search</a> 只搜索本地桶内容</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install scoop<span class="literal">-search</span></span><br><span class="line">&gt; scoop<span class="literal">-search</span> name</span><br></pre></td></tr></table></figure>

<h3 id="软件重名"><a href="#软件重名" class="headerlink" title="软件重名"></a>软件重名</h3><p>如果软件重名，使用如下方式安装，否则会安装查到的第一个软件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install bucket/name</span><br></pre></td></tr></table></figure>

<h3 id="指定软件版本"><a href="#指定软件版本" class="headerlink" title="指定软件版本"></a>指定软件版本</h3><p>如果要安装旧版软件且 versions 中没有，使用如下方式安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install name@version</span><br></pre></td></tr></table></figure>

<p>一个该软件的 manifest 将会被生成在 <code>~\scoop\workspace</code>，该软件将不会被更新</p>
<h3 id="多版本软件优先级"><a href="#多版本软件优先级" class="headerlink" title="多版本软件优先级"></a>多版本软件优先级</h3><p>如果你安装了一个软件的多个衍生版本，例如 temurin-lts-jdk 和 temurin8-jdk，最后一个安装的版本将会在命令行生效，如果需要在命令行使用其他版本，执行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop reset name</span><br></pre></td></tr></table></figure>

<h2 id="编写自己的-manifest"><a href="#编写自己的-manifest" class="headerlink" title="编写自己的 manifest"></a>编写自己的 manifest</h2><p>以 <a href="https://github.com/vzhd1701/gridplayer">gridplayer</a> 为例，在其主页上找到 Windows 版本的安装包，便携版本优先。</p>
<p>在命令行输入以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop create https://github.com/vzhd1701/gridplayer/releases/download/v0.<span class="number">4.3</span>/GridPlayer<span class="literal">-0</span>.<span class="number">4.3</span><span class="literal">-win64-portable</span>.zip</span><br></pre></td></tr></table></figure>

<p>依次选择 <code>App name</code> 和 <code>Version</code>，当前目录下将会生成 <code>gridplayer.json</code> 文件，其内容为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/vzhd1701/gridplayer/releases/download/v0.4.3/GridPlayer-0.4.3-win64-portable.zip&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extract_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v0.4.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;depends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，生成的内容并不是很完善，需要手动补充完善。</p>
<p>最终 manifest 如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.4.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Play videos side-by-side&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/vzhd1701/gridplayer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GPL-3.0-only&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;64bit&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/vzhd1701/gridplayer/releases/download/v0.4.3/GridPlayer-0.4.3-win64-portable.zip&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;hash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1a233cb642cdeb3170c098651bfdc3ec9017d390b9991b53b1a9f03c5aca6d39&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extract_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GridPlayer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;shortcuts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="string">&quot;GridPlayer.exe&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GridPlayer&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;persist&quot;</span><span class="punctuation">:</span> <span class="string">&quot;portable_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;checkver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;autoupdate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;64bit&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/vzhd1701/gridplayer/releases/download/v$version/GridPlayer-$version-win64-portable.zip&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hash&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$baseurl/checksums.sha256&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>package manager</tag>
        <tag>Scoop</tag>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统后恢复Scoop</title>
    <url>/2023/04/09/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DScoop/</url>
    <content><![CDATA[<p>近期重装了系统，之前 scoop 使用安装的软件不想花时间重装，搜索到以下答案：</p>
<ul>
<li><a href="https://github.com/ScoopInstaller/Scoop/issues/2894#issuecomment-447276027">How to use scoop after reinstalling the system</a></li>
<li><a href="https://jiayaoo3o.github.io/2019/03/19/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E4%BD%BF%E7%94%A8scoop/">重装系统后如何恢复使用 scoop</a></li>
</ul>
<p>一顿操作完成后，可以正常使用软件，但是在更新时会报如下错误，原因是 git 默认拒绝解析非当前用户拥有的存储库的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: detected dubious ownership in repository</span><br></pre></td></tr></table></figure>

<p>一个解决办法是执行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --add safe.directory path/to/error/directory</span><br></pre></td></tr></table></figure>

<p>如果 bucket 文件夹较多，可以执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --add safe.directory *</span><br></pre></td></tr></table></figure>

<p>该方法有一定的安全风险，另一种从根源解决的方法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">更改scoop文件夹所有者为当前用户，并勾选应用到所有的子目录和文件</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
