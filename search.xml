<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tomcat 的三种 IO 模型</title>
    <url>/2023/tomcat-io/</url>
    <content><![CDATA[<p>在用 Java 手写服务器示例代码的时候有一些疑惑，加之日常开发中只对 Tomcat 有浅显的理解，知道其是用线程池处理请求，所以就翻了翻 Tomcat 的源代码。本文记录 Tomcat 中 IO 模型的相关代码，版本为 tomcat-embed-core:9.0.78。</p>
<span id="more"></span>

<p>Tomcat 支持的 IO 模型有 APR、NIO、NIO2 三种。</p>
<p>APR、NIO 两种实现方式本质上都是 reactor 模式，使用 IO 多路复用和线程池实现并发处理多个客户端请求。使用的是主从 reactor 多线程模型。其中 acceptor 为主 reactor，负责接受新连接。poller 为从 reactor，负责监控 IO 事件，worker 为执行 IO 操作和业务代码的线程池。</p>
<h2 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h2><p>Tomcat 中封装 IO 相关方法的类叫做 endpoint，负责创建 acceptor, poller, worker 等对象，并负责这几个类之间的交互，作用是胶水代码。<br>抽象类为 AbstractEndpoint，具体的子类有 AprEndpoint、NioEndpoint 和 Nio2Endpoint，分别代表 APR、NIO 和 NIO2 三种 IO 模型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEndpoint</span>&lt;S,U&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * endpoint 的入口，用于启动 acceptor, poller, worker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 worker 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        internalExecutor = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (getUseVirtualThreads()) &#123;</span><br><span class="line">            <span class="comment">// 创建 Java 21 虚拟线程池</span></span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">VirtualThreadExecutor</span>(getName() + <span class="string">&quot;-virt-&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建多线程线程池，默认核心线程数 10，最大线程数 200，优先级 5</span></span><br><span class="line">            <span class="type">TaskQueue</span> <span class="variable">taskqueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">            <span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">            taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并启动 acceptor 线程，APR, NIO 使用该默认实现，NIO2 重写了该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startAcceptorThread</span><span class="params">()</span> &#123;</span><br><span class="line">        acceptor = <span class="keyword">new</span> <span class="title class_">Acceptor</span>&lt;&gt;(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> getName() + <span class="string">&quot;-Acceptor&quot;</span>;</span><br><span class="line">        acceptor.setThreadName(threadName);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(acceptor, threadName);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受连接，被 acceptor 调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> U <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置连接，被 acceptor 调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(U socket)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 socket 事件，被 poller 调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span><br><span class="line"><span class="params">            SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 socket 处理器</span></span><br><span class="line">            SocketProcessorBase&lt;S&gt; sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">            <span class="comment">// 处理 socket 事件，根据 dispatch 判断是否使用 worker 处理</span></span><br><span class="line">            <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getExecutor();</span><br><span class="line">            <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="literal">null</span>) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 socket 处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> SocketProcessorBase&lt;S&gt; <span class="title function_">createSocketProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">            SocketWrapperBase&lt;S&gt; socketWrapper, SocketEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AprEndpoint"><a href="#AprEndpoint" class="headerlink" title="AprEndpoint"></a>AprEndpoint</h3><p>该类将在 Tomcat 10 被废弃，APR 通过 JNI 进行 socket 操作，相比使用 Java IO API 效率更高。<br>使用该类会创建以下线程（池）</p>
<ul>
<li>acceptor 线程</li>
<li>poller 线程</li>
<li>sendfile 线程</li>
<li>worker 线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AprEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractEndpoint</span>&lt;Long,Long&gt; <span class="keyword">implements</span> <span class="title class_">SNICallBack</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">serverSock</span> <span class="operator">=</span> Socket.create(family, Socket.SOCK_STREAM, <span class="number">0</span>, rootPool);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Socket.bind(serverSock, sockAddress);</span><br><span class="line">        ret = Socket.listen(serverSock, getAcceptCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 APR endpoint，启动 acceptor, poller, sendfile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            running = <span class="literal">true</span>;</span><br><span class="line">            paused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 worker 线程池</span></span><br><span class="line">            <span class="keyword">if</span> (getExecutor() == <span class="literal">null</span>) &#123;</span><br><span class="line">                createExecutor();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 poller 线程</span></span><br><span class="line">            poller = <span class="keyword">new</span> <span class="title class_">Poller</span>();</span><br><span class="line">            poller.init();</span><br><span class="line">            poller.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 sendfile 线程</span></span><br><span class="line">            <span class="keyword">if</span> (getUseSendfile()) &#123;</span><br><span class="line">                sendfile = <span class="keyword">new</span> <span class="title class_">Sendfile</span>();</span><br><span class="line">                sendfile.init();</span><br><span class="line">                sendfile.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 acceptor 线程</span></span><br><span class="line">            startAcceptorThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AprEndpoint 接受连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">socket</span> <span class="operator">=</span> Socket.accept(serverSock);</span><br><span class="line">        <span class="keyword">return</span> Long.valueOf(socket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AprEndpoint 设置连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(Long socket)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">AprSocketWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AprSocketWrapper</span>(socket, <span class="built_in">this</span>);</span><br><span class="line">            connections.put(socket, wrapper);</span><br><span class="line">            wrapper.setKeepAliveLeft(getMaxKeepAliveRequests());</span><br><span class="line">            wrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            wrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            getExecutor().execute(<span class="keyword">new</span> <span class="title class_">SocketWithOptionsProcessor</span>(wrapper));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把socket交给poller处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">SocketWithOptionsProcessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> socket.getLock();</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getPoller().add(socket.getSocket().longValue(), getConnectionTimeout(), Poll.APR_POLLIN);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NioEndpoint"><a href="#NioEndpoint" class="headerlink" title="NioEndpoint"></a>NioEndpoint</h3><p>NioEndpoint 通过 Java NIO 进行同步非阻塞 IO 操作。相比使用同步阻塞 IO，大大减少了高并发下所需线程的数量，因而效率更高。</p>
<p>使用该类会创建以下线程（池）</p>
<ul>
<li>acceptor 线程（阻塞接受新连接）</li>
<li>poller 线程（配置 IO 多路复用，检测 IO 事件）</li>
<li>worker 线程池（处理 IO 事件）</li>
</ul>
<p>acceptor 循环接受连接并将注册事件放入 poller 的事件队列，poller 循环处理事件队列中的事件并检测 IO 事件，如果发生 IO 事件让 worker 进行 IO 操作并执行业务代码。</p>
<p>功能示意图如下</p>
<p><img src="/2023/tomcat-io/nio.png" alt="NIO"></p>
<p>向服务器发出一个请求，查看线程状态。编号 1-10 的线程为 worker 线程。</p>
<p><img src="/2023/tomcat-io/nio%E7%BA%BF%E7%A8%8B.png" alt="NIO thread"></p>
<p>收到请求后，一个 worker 线程由 Park 状态转为 Running 状态；接着服务器访问外部服务，等待 IO 期间线程转为 Wait 状态；访问外部服务完成后整个请求结束，线程又转为 Park 状态。</p>
<p>NIO 相关代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel,SocketChannel&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getAddress(), getPortWithOffset());</span><br><span class="line">        serverSock.bind(addr, getAcceptCount());</span><br><span class="line">        serverSock.configureBlocking(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 NIO endpoint，启动 acceptor, poller</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            running = <span class="literal">true</span>;</span><br><span class="line">            paused = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 创建 worker 线程池</span></span><br><span class="line">            <span class="keyword">if</span> (getExecutor() == <span class="literal">null</span>) &#123;</span><br><span class="line">                createExecutor();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动 poller 线程</span></span><br><span class="line">            poller = <span class="keyword">new</span> <span class="title class_">Poller</span>();</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">pollerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(poller, getName() + <span class="string">&quot;-Poller&quot;</span>);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">            <span class="comment">// 启动 acceptor 线程</span></span><br><span class="line">            startAcceptorThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NioEndpoint 接受连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SocketChannel <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 阻塞接受连接</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">result</span> <span class="operator">=</span> serverSock.accept();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NioEndpoint 设置连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(SocketChannel socket)</span> &#123;</span><br><span class="line">        <span class="type">NioSocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketBufferHandler</span> <span class="variable">bufhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketBufferHandler</span>(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="type">NioChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioChannel</span>(bufhandler);</span><br><span class="line">            <span class="type">NioSocketWrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioSocketWrapper</span>(channel, <span class="built_in">this</span>);</span><br><span class="line">            channel.reset(socket, newWrapper);</span><br><span class="line">            connections.put(socket, newWrapper);</span><br><span class="line">            socketWrapper = newWrapper;</span><br><span class="line">            <span class="comment">// 因使用 IO 多路复用，设置为非阻塞 IO</span></span><br><span class="line">            socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (getUnixDomainSocketPath() == <span class="literal">null</span>) &#123;</span><br><span class="line">                socketProperties.setProperties(socket.socket());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            socketWrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setKeepAliveLeft(NioEndpoint.<span class="built_in">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">            <span class="comment">// 将 socket 注册到 poller</span></span><br><span class="line">            poller.register(socketWrapper);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nio2Endpoint"><a href="#Nio2Endpoint" class="headerlink" title="Nio2Endpoint"></a>Nio2Endpoint</h3><p>Nio2Endpoint 通过 Java NIO 进行异步 IO 操作，相比使用同步非阻塞 IO，应用不需将数据拷贝到进程中，而由内核代为完成后通知应用，执行回调。Java 异步 IO 在 Windows 中通过 IOCP 实现，在 Linux 中通过 epoll 模拟实现，所以理论上在 Linux 下同步非阻塞 IO 和异步 IO 的效率无明显差别。</p>
<p>使用该类会创建以下线程（池）</p>
<ul>
<li>acceptor 线程</li>
<li>worker 线程池</li>
</ul>
<p>相比同步非阻塞 IO，少了 poller，操作系统承担了 poller 的工作和。</p>
<p>功能示意图如下</p>
<p><img src="/2023/tomcat-io/nio2.png" alt="NIO2"></p>
<p>向服务器发出一个请求，查看线程状态。编号 1-10 的线程为 worker 线程。</p>
<p><img src="/2023/tomcat-io/nio2%E7%BA%BF%E7%A8%8B.png" alt="NIO2 thread"></p>
<p>收到请求后，一个 worker 线程由 Park 状态转为 Running 状态；接着服务器访问外部服务，等待 IO 期间线程转为 Wait 状态；访问外部服务完成后整个请求结束，线程又转为 Park 状态。</p>
<p>NIO2 相关代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO2 endpoint.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nio2Endpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;Nio2Channel,AsynchronousSocketChannel&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 使用 worker 线程池处理 IO 事件</span></span><br><span class="line">        threadGroup = AsynchronousChannelGroup.withThreadPool((ExecutorService) getExecutor());</span><br><span class="line">        serverSock = AsynchronousServerSocketChannel.open(threadGroup);</span><br><span class="line">        socketProperties.setProperties(serverSock);</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getAddress(), getPortWithOffset());</span><br><span class="line">        <span class="comment">// 绑定地址</span></span><br><span class="line">        serverSock.bind(addr, getAcceptCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 NIO2 endpoint, 启动 acceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建 worker 线程池</span></span><br><span class="line">        <span class="keyword">if</span> (getExecutor() == <span class="literal">null</span>) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动 acceptor 线程</span></span><br><span class="line">        startAcceptorThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 NIO2 acceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startAcceptorThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">            acceptor = <span class="keyword">new</span> <span class="title class_">Nio2Acceptor</span>(<span class="built_in">this</span>);</span><br><span class="line">            acceptor.setThreadName(getName() + <span class="string">&quot;-Acceptor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 worker 线程池启动 accepor</span></span><br><span class="line">        getExecutor().execute(acceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞接受连接，该方法未被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AsynchronousSocketChannel <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AsynchronousSocketChannel</span> <span class="variable">result</span> <span class="operator">=</span> serverSock.accept().get();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Nio2Endpoint 设置连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(AsynchronousSocketChannel socket)</span> &#123;</span><br><span class="line">        <span class="type">Nio2SocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketBufferHandler</span> <span class="variable">bufhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketBufferHandler</span>(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="type">Nio2Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Nio2Channel</span>(bufhandler);</span><br><span class="line">            <span class="type">Nio2SocketWrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Nio2SocketWrapper</span>(channel, <span class="built_in">this</span>);</span><br><span class="line">            channel.reset(socket, newWrapper);</span><br><span class="line">            connections.put(socket, newWrapper);</span><br><span class="line">            socketWrapper = newWrapper;</span><br><span class="line"></span><br><span class="line">            socketProperties.setProperties(socket);</span><br><span class="line">            socketWrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setKeepAliveLeft(Nio2Endpoint.<span class="built_in">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">            <span class="comment">// 调用 AbstractEndpoint.processSocket 方法处理 IO 事件。因为是异步 IO，所以不需要使用新线程处理 IO 事件</span></span><br><span class="line">            <span class="keyword">return</span> processSocket(socketWrapper, SocketEvent.OPEN_READ, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">SocketProcessor</span> <span class="keyword">extends</span> <span class="title class_">SocketProcessorBase</span>&lt;Nio2Channel&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被 AbstractEndpoint.processSocket 调用，处理 IO 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">launch</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketState</span> <span class="variable">state</span> <span class="operator">=</span> SocketState.OPEN;</span><br><span class="line">            <span class="comment">// 处理 IO 事件</span></span><br><span class="line">            <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">                state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = getHandler().process(socketWrapper, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (state == SocketState.UPGRADING) &#123;</span><br><span class="line">                launch = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (launch) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 使用新线程处理 IO 事件</span></span><br><span class="line">                    getExecutor().execute(<span class="keyword">new</span> <span class="title class_">SocketProcessor</span>(socketWrapper, SocketEvent.OPEN_READ));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h2><p>acceptor 的功能如其名称，用于接受 socket 连接请求。产生一个与客户端的连接的 socket 后，再将其交给 poller 处理。<br>acceptor 的代码逻辑特别简单，不断地调用 <code>endpoint.serverSocketAccept</code> 产生 socket 连接，调用 <code>endpoint.setSocketOptions</code> 设置 socket。</p>
<h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h3><p>NIO、APR 的 acceptor 为类 Acceptor，Acceptor 主要代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span>&lt;U&gt; <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线程中循环接受新连接直到收到关闭命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">errorDelay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stopCalled) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 接受连接</span></span><br><span class="line">                <span class="type">U</span> <span class="variable">socket</span> <span class="operator">=</span> endpoint.serverSocketAccept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</span><br><span class="line">                <span class="comment">// 连接失败进行延时操作</span></span><br><span class="line">                errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// endpoint 设置连接，处理失败则关闭连接</span></span><br><span class="line">            <span class="keyword">if</span> (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                endpoint.closeSocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时时长指数增加，防止短时间内产生大量错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_ERROR_DELAY</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ERROR_DELAY</span> <span class="operator">=</span> <span class="number">1600</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">handleExceptionWithDelay</span><span class="params">(<span class="type">int</span> currentErrorDelay)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次不延时</span></span><br><span class="line">        <span class="keyword">if</span> (currentErrorDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Thread.sleep(currentErrorDelay);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentErrorDelay == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INITIAL_ERROR_DELAY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentErrorDelay &lt; MAX_ERROR_DELAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentErrorDelay * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MAX_ERROR_DELAY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nio2Acceptor"><a href="#Nio2Acceptor" class="headerlink" title="Nio2Acceptor"></a>Nio2Acceptor</h3><p>NIO2 中的 acceptor 为类 Nio2Acceptor，Nio2Acceptor 重写了 Acceptor 的 <code>run</code> 方法，用异步 IO 替代同步 IO。且实现了 CompletionHandler 接口，用于处理异步 IO 完成事件。</p>
<p>Nio2Acceptor 的主要代码如下，其中没有调用 <code>endpoint.serverSocketAccept</code> 产生 socket，而是直接调用 <code>serverSock.accept</code> 产生 socket，另一个异同是 Nio2Acceptor 的 run 方法中没有循环，而是通过异步 IO 的回调函数重新接受新请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Nio2Acceptor</span> <span class="keyword">extends</span> <span class="title class_">Acceptor</span>&lt;AsynchronousSocketChannel&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果达到最大连接数，等待</span></span><br><span class="line">        countUpOrAwaitConnection();</span><br><span class="line">        <span class="comment">// 异步 IO，连接完成后由 completed 方法处理，失败由 failed 方法处理</span></span><br><span class="line">        serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接请求成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socket,</span></span><br><span class="line"><span class="params">            Void attachment)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步接受新请求</span></span><br><span class="line">        <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;</span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getConnectionCount() &lt; getMaxConnections()) &#123;</span><br><span class="line">            countUpOrAwaitConnection();</span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 达到最大连接数，使用新线程接受请求</span></span><br><span class="line">            getExecutor().execute(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 socket</span></span><br><span class="line">        <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">            closeSocket(socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接请求失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable t, Void attachment)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;</span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用新线程接受请求</span></span><br><span class="line">            getExecutor().execute(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownConnection();</span><br><span class="line">        <span class="comment">// 失败后等待一段事件</span></span><br><span class="line">        errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poller"><a href="#poller" class="headerlink" title="poller"></a>poller</h2><p>poller 的作用是将新 socket 注册到 selector 并轮询是否有 IO 事件发生。</p>
<h3 id="APR-poller"><a href="#APR-poller" class="headerlink" title="APR poller"></a>APR poller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        pollerThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(poller, getName() + <span class="string">&quot;-Poller&quot;</span>);</span><br><span class="line">        pollerThread.setPriority(threadPriority);</span><br><span class="line">        pollerThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        pollerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SocketList</span> <span class="variable">localAddList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketList</span>(getMaxConnections());</span><br><span class="line">        <span class="keyword">while</span> (pollerRunning) &#123;</span><br><span class="line">            <span class="type">SocketInfo</span> <span class="variable">info</span> <span class="operator">=</span> localAddList.get();</span><br><span class="line">            <span class="keyword">while</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// poll 操作</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rv</span> <span class="operator">=</span> Poll.poll(aprPoller, pollTime, desc, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; rv; n++) &#123;</span><br><span class="line">                    processSocket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NIO-poller"><a href="#NIO-poller" class="headerlink" title="NIO poller"></a>NIO poller</h3><p>poller 负责两件事，处理 poller 事件，处理 IO 事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">wakeupCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// IO 多路复用选择器</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">// poller 事件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronizedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 socket 的读事件注册到事件队列中，被 acceptor 调用 setSocketOptions 时间接调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> NioSocketWrapper socketWrapper)</span> &#123;</span><br><span class="line">        socketWrapper.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        <span class="type">PollerEvent</span> <span class="variable">pollerEvent</span> <span class="operator">=</span> createPollerEvent(socketWrapper, OP_REGISTER);</span><br><span class="line">        addEvent(pollerEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEvent</span><span class="params">(PollerEvent event)</span> &#123;</span><br><span class="line">        events.offer(event);</span><br><span class="line">        <span class="comment">// wakeupCounter 为 -1 时唤醒 selector，处理新事件</span></span><br><span class="line">        <span class="keyword">if</span> (wakeupCounter.incrementAndGet() == <span class="number">0</span>) &#123;</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环处理 poller 事件和 IO 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasEvents</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hasEvents = events();</span><br><span class="line">                <span class="comment">// 事件队列有新事件，wakeupCounter 为 -1 时，selector 正在进行 select 操作</span></span><br><span class="line">                <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 检查有没有 IO，有 IO 先处理 IO</span></span><br><span class="line">                    keyCount = selector.selectNow();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有新事件就等待已注册 IO 的，默认超时 1000ms</span></span><br><span class="line">                    keyCount = selector.select(selectorTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 没有 socket 可读写</span></span><br><span class="line">                <span class="keyword">if</span> (keyCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    hasEvents = (hasEvents | events());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历 selector key，处理 IO 事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (iterator != <span class="literal">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="type">NioSocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> (NioSocketWrapper) sk.attachment();</span><br><span class="line">                processKey(sk, socketWrapper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理超时的连接</span></span><br><span class="line">            timeout(keyCount,hasEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        getStopLatch().countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 poller 事件队列中的事件，如果处理了事件返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">events</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PollerEvent</span> <span class="variable">pe</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != <span class="literal">null</span>; i++ ) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">NioSocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> pe.getSocketWrapper();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> socketWrapper.getSocket().getIOChannel();</span><br><span class="line">            <span class="comment">// 注册读事件到 selector</span></span><br><span class="line">            sc.register(getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 IO 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper socketWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sk.isReadable() || sk.isWritable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (socketWrapper.getSendfileData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                processSendfile(sk, socketWrapper, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 先读再写</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    processSocket(socketWrapper, SocketEvent.OPEN_READ, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sk.isWritable()) &#123;</span><br><span class="line">                    processSocket(socketWrapper, SocketEvent.OPEN_WRITE, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AprEndpoint-1"><a href="#AprEndpoint-1" class="headerlink" title="AprEndpoint"></a>AprEndpoint</h3><p>跟 NioEndpoint 一样，AprEndpoint 也实现了非阻塞 I&#x2F;O，它们的区别是：NioEndpoint 通过调用 Java 的 NIO API 来实现非阻塞 I&#x2F;O，而 AprEndpoint 是通过 JNI 调用 APR 本地库而实现非阻塞 I&#x2F;O 的。在某些场景下，比如需要频繁与操作系统进行交互，Socket 网络通信就是这样一个场景， 特别是如果你的 Web 应用使用了 TLS 来加密传输，我们知道 TLS 协议在握手过程中有多 次网络交互，在这种情况下 Java 跟 C 语言程序相比还是有一定的差距，而这正是 APR 的 强项。Tomcat 本身是 Java 编写的，为了调用 C 语言编写的 APR，需要通过 JNI 方式来调用。 JNI（Java Native Interface） 是 JDK 提供的一个编程接口，它允许 Java 程序调用其他语 言编写的程序或者代码库，其实 JDK 本身的实现也大量用到 JNI 技术来调用本地 C 程序 库。</p>
<p>它跟 NioEndpoint 的工作原理很像，有 LimitLatch、Acceptor、Poller、 SocketProcessor 和 Http11Processor，只是 Acceptor 和 Poller 的实现和 NioEndpoint 不同。</p>
<p>Acceptor 接收到一个新的 Socket 连接后，按照 NioEndpoint 的实现，它会把这个 Socket 交给 Poller 去查询 I&#x2F;O 事件。AprEndpoint 也是这样做的，不过 AprEndpoint 的 Poller 并不是调用 Java NIO 里的 Selector 来查询 Socket 的状态，而是通过 JNI 调用 APR 中的 poll 方法，而 APR 又是调用了操作系统的 epoll API 来实现的。在 AprEndpoint 中，我们可以配置一个叫 deferAccept 的参数，它对应的是 TCP 协议中的 TCP_DEFER_ACCEPT，设置这个参数后，当 TCP 客户端有新的连接请求到达时，TCP 服务端先不建立连接，而是再等等，直到客户端有请求数据发过来时再建立连接。这样的好处是服务端不需要用 Selector 去反复查询请求数据是否就绪。这是一种 TCP 协议层的优化，不是每个操作系统内核都支持，因为 Java 作为一种跨平台语言，需要屏蔽各种操作系统的差异，因此并没有把这个参数提供给用户；但是对于 APR 来说，它的目的就是尽可能提升性能，因此它向用户暴露了这个参数。</p>
<h3 id="Nio2Endpoint-1"><a href="#Nio2Endpoint-1" class="headerlink" title="Nio2Endpoint"></a>Nio2Endpoint</h3><p>接口，</p>
<p>Accpetor 的功能就是监听连接，接收并建立连接。它的本质就是调用了四个操作系统 API：socket、bind、listen 和 accept。那 Java 语言如何直接调用 C 语言 API 呢？答案 就是通过 JNI。</p>
<p>其中两个重要组件：Acceptor 和 SocketProcessor。</p>
<p>Acceptor 用于监听 Socket 连接请求，SocketProcessor 用于处理收到的 Socket 请求，提交到线程池 Executor 处理。</p>
]]></content>
  </entry>
  <entry>
    <title>数据库分页排序数据重复</title>
    <url>/2024/paging-sorting-data-duplication/</url>
    <content><![CDATA[<p>在需求测试中碰到了分页排序数据重复的问题，在翻页时发现部分数据在多页中出现。初次碰到感觉该问题比较反直觉，排序和分页放在一起用时，在我看来应该是先排序再分页，排序顺序确定的情况下，分页每次取部分数据，是不应该出现数据重复出现在不同页的情况的。</p>
<span id="more"></span>

<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>开发环境用的是 <code>Oracle</code>，在自己的电脑用 <code>MySQL</code> 也可以复现问题，<code>MySQL</code> 版本采用 8.2.0。</p>
<h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>新建如下表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入如下数据</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>9</td>
<td>3</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>现在进行分页查询，每页两条数据，查询第一页数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">0</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
</tr>
</tbody></table>
<p>查询第二页数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">2</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>预期的结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>x</td>
<td>2</td>
</tr>
</tbody></table>
<p>实际结果如下</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>可以看到，id 为 10 的数据在两次分页查询中出现了两次，id 为 5 的数据从未出现。通过分页查询，用户永远也无法看到 id 为 5 的数据。</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>查询相关资料，MySQL 的文档其实说明了原因<br><a href="https://dev.mysql.com/doc/refman/8.3/en/limit-optimization.html">MySQL :: MySQL 8.3 Reference Manual :: 8.2.1.19 LIMIT Query Optimization</a></p>
<blockquote>
<p>If multiple rows have identical values in the <code>ORDER BY</code> columns, the server is free to return those rows in any order, and may do so differently depending on the overall execution plan. In other words, the sort order of those rows is nondeterministic with respect to the nonordered columns.</p>
<p>One factor that affects the execution plan is <code>LIMIT</code>, so an <code>ORDER BY</code> query with and without <code>LIMIT</code> may return rows in different orders.</p>
</blockquote>
<p>简言之，<code>ORDER BY</code> 的列如果值相同，数据库不保证返回行的顺序，结果受整体执行计划影响。</p>
<p>那么文章开头问题的原因显而易见，<code>LIMIT</code>改变了执行计划，<code>ORDER BY</code> 受此影响，对不同的<code>LIMIT</code>参数返回了顺序不同的结果行，通过以下<code>SQL</code>可以证实</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">0</span>,<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>执行结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>从第 3 行起取 2 行结果，与查询第二页数据结果一致。</p>
<p><strong><code>ORDER BY</code> 的结果顺序受执行计划影响， <code>LIMIT</code> 改变了执行计划，导致了分页排序数据重复问题的发生。</strong></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>MySQL</code>文档给的解决方案是在<code>ORDER BY</code> 的字段中增加不含重复值的列，如<code>id</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name, id limit <span class="number">0</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name, id limit <span class="number">2</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>问题解决。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>执行文中的<code>SQL</code>时，执行计划中均出现了 <code>Using filesort</code>，之后另起一篇分析一下<code>MySQL</code>的排序算法，找到本文问题的代码根源。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>test</td>
<td></td>
<td>ALL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>10</td>
<td>100.0</td>
<td>Using filesort</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>解决问题</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>生产问题</tag>
      </tags>
  </entry>
  <entry>
    <title>读 Mybatis 源码</title>
    <url>/2024/mybatis/</url>
    <content><![CDATA[<p>通过编程方式使用 Mybatis（不使用 Spring）时，最重要的类莫过于 SqlSession。通过该接口中的操作，开发者可以实现执行查增改删的 Statement 并获取多种类型的结果、执行批量、管理事务、管理会话、获取 Mapper。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>SqlSession 的方法有如下四类</p>
<ul>
<li>增删查改</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>selectOne</td>
<td>获取单行数据</td>
</tr>
<tr>
<td>selectList</td>
<td>获取列表数据</td>
</tr>
<tr>
<td>selectMap</td>
<td>获取 Map 数据</td>
</tr>
<tr>
<td>selectCursor</td>
<td>获取游标数据</td>
</tr>
<tr>
<td>select</td>
<td>获取并处理每行数据</td>
</tr>
<tr>
<td>insert</td>
<td>插入数据</td>
</tr>
<tr>
<td>update</td>
<td>更新数据</td>
</tr>
<tr>
<td>delete</td>
<td>删除数据</td>
</tr>
</tbody></table>
<ul>
<li>事务和批量操作</li>
</ul>
<table>
<thead>
<tr>
<th>方法命</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>commit</td>
<td>flush batch statements and commit</td>
</tr>
<tr>
<td>rollback</td>
<td>discard pending batch statements and roll database connection back</td>
</tr>
<tr>
<td>flushStatements</td>
<td>flush batch statements</td>
</tr>
</tbody></table>
<ul>
<li>管理会话</li>
</ul>
<table>
<thead>
<tr>
<th>方法命</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>close</td>
<td>关闭会话</td>
</tr>
<tr>
<td>clearCache</td>
<td>清理本地会话缓存</td>
</tr>
<tr>
<td>getConfiguration</td>
<td>获取当前配置</td>
</tr>
<tr>
<td>getConnection</td>
<td>获取内部数据库连接</td>
</tr>
</tbody></table>
<ul>
<li>获取 Mapper</li>
</ul>
<table>
<thead>
<tr>
<th>方法命</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>getMapper</td>
<td>获取 Mapper</td>
</tr>
</tbody></table>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mybatis 的主要接口，通过该接口执行命令，获取 mapper，管理事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlSession</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单行数据映射的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;       返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> statement 唯一定位需要执行的 statement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 映射的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单行数据映射的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter statement 的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 映射的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取多行数据映射的对象列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;E&gt; 列表元素类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 映射的对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取多行数据映射的对象列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 映射的对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取多行数据映射的对象列表，分页</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowBounds 分页参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 映射的对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 selectList 的基础上，以 mapKey 属性为 key，将 List 转换为 Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt;    返回的 Map 的 key 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;    返回的 Map 的 value 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapKey 作为 key 的属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, String mapKey)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 selectList 的基础上，以 mapKey 属性为 key，将 List 转换为 Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 selectList 的基础上，以 mapKey 属性为 key，将 List 转换为 Map，分页</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用游标对 selectList 结果懒加载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用游标对 selectList 结果懒加载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用游标对 selectList 结果懒加载，分页</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ResultHandler 对每行映射的对象进行处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 处理每行对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, ResultHandler handler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ResultHandler 对每行映射的对象进行处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, Object parameter, ResultHandler handler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ResultHandler 对每行映射的对象进行处理，分页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 插入的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute an insert statement with the given parameter object. Any generated</span></span><br><span class="line"><span class="comment">     * autoincrement values or selectKey</span></span><br><span class="line"><span class="comment">     * entries will modify the given parameter object properties. Only the number of</span></span><br><span class="line"><span class="comment">     * rows affected will be returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 插入的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 更新的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 更新的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新 batch statements 并提交数据库连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新 batch statements 并提交数据库连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> force 强制连接提交</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> force)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略等待的 batch statements，回滚连接。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略等待的 batch statements，回滚连接。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> force 强制连接回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(<span class="type">boolean</span> force)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新批量statement</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 更新记录的 batchResult list</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.0.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;BatchResult&gt; <span class="title function_">flushStatements</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除本地会话缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clearCache</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 mapper</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;  mapper 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type mapper 接口类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 绑定到当前 SqlSession 的 mapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取内部的数据库连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Connection <span class="title function_">getConnection</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><h3 id="DefaultSqlSession"><a href="#DefaultSqlSession" class="headerlink" title="DefaultSqlSession"></a>DefaultSqlSession</h3><p>默认实现，不是线程安全的。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SqlSession 默认实现，不是线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title class_">SqlSession</span> &#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">    <span class="comment">// 执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="comment">// 自动提交</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> autoCommit;</span><br><span class="line">    <span class="comment">// 是否有脏数据，调用 insert、update 或 delete 会置为 true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> dirty;</span><br><span class="line">    <span class="comment">// 保存游标，此处何时回收？</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration 配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor      执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoCommit    自动提交</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configuration = configuration;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">        <span class="built_in">this</span>.dirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.autoCommit = autoCommit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器，默认不自动提交</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration 配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor      执行器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(configuration, executor, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询列表，如果列表很大此处会出现性能问题</span></span><br><span class="line">        List&lt;T&gt; list = <span class="built_in">this</span>.selectList(statement, parameter);</span><br><span class="line">        <span class="comment">// 只有一条就返回</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果超出一条会抛异常，零条返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooManyResultsException</span>(</span><br><span class="line">                    <span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + list.size());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowBounds)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询列表</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; list = selectList(statement, parameter, rowBounds);</span><br><span class="line">        <span class="keyword">final</span> DefaultMapResultHandler&lt;K, V&gt; mapResultHandler = <span class="keyword">new</span> <span class="title class_">DefaultMapResultHandler</span>&lt;&gt;(mapKey,</span><br><span class="line">                configuration.getObjectFactory(), configuration.getObjectWrapperFactory(),</span><br><span class="line">                configuration.getReflectorFactory());</span><br><span class="line">        <span class="keyword">final</span> DefaultResultContext&lt;V&gt; context = <span class="keyword">new</span> <span class="title class_">DefaultResultContext</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (V o : list) &#123;</span><br><span class="line">            context.nextResultObject(o);</span><br><span class="line">            mapResultHandler.handleResult(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mapResultHandler.getMappedResults();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">            dirty |= ms.isDirtySelect();</span><br><span class="line">            Cursor&lt;T&gt; cursor = executor.queryCursor(ms, wrapCollection(parameter), rowBounds);</span><br><span class="line">            registerCursor(cursor);</span><br><span class="line">            <span class="keyword">return</span> cursor;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">            dirty |= ms.isDirtySelect();</span><br><span class="line">            <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, handler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span> &#123;</span><br><span class="line">        selectList(statement, parameter, rowBounds, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dirty = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">            <span class="keyword">return</span> executor.update(ms, wrapCollection(parameter));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error updating database.  Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> force)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor.commit(isCommitOrRollbackRequired(force));</span><br><span class="line">            dirty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error committing transaction.  Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeCursors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cursorList != <span class="literal">null</span> &amp;&amp; !cursorList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cursor&lt;?&gt; cursor : cursorList) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cursor.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error closing cursor.  Cause: &quot;</span> + e, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cursorList.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册游标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;    返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cursor 游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">registerCursor</span><span class="params">(Cursor&lt;T&gt; cursor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cursorList == <span class="literal">null</span>) &#123;</span><br><span class="line">            cursorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        cursorList.add(cursor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要提交或回滚，关闭自动提交且有脏数据时需要</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> force 是否强制返回 true</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否需要提交或回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCommitOrRollbackRequired</span><span class="params">(<span class="type">boolean</span> force)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !autoCommit &amp;&amp; dirty || force;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Collection 和数组包装成 ParamMap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ParamNameResolver.wrapToMapIfCollection(object, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SqlSessionManager"><a href="#SqlSessionManager" class="headerlink" title="SqlSessionManager"></a>SqlSessionManager</h3><p>代理 SqlSession</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SqlSession 管理器，内部有线程私有的 SqlSession，如果 SqlSession 为空，临时开打一个 SqlSession 执行命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionManager</span> <span class="keyword">implements</span> <span class="title class_">SqlSessionFactory</span>, SqlSession &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="comment">// SqlSession 代理实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line">    <span class="comment">// 线程私有的 SqlSession</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;SqlSession&gt; localSqlSession = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SqlSessionManager</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionProxy = (SqlSession) Proxy.newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; SqlSession.class &#125;, <span class="keyword">new</span> <span class="title class_">SqlSessionInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建 SqlSessionManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionManager <span class="title function_">newInstance</span><span class="params">(Reader reader)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionManager</span>(<span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动内部 SqlSession</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startManagedSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.localSqlSession.set(openSession());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部 SqlSession 是否启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isManagedSessionStarted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.localSqlSession.get() != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Configuration <span class="title function_">getConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.getConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 sqlSessionProxy 执行命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionProxy.selectOne(statement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Configuration 获取 Mapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getConfiguration().getMapper(type, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 localSqlSession 管理会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> localSqlSession.get();</span><br><span class="line">        <span class="keyword">if</span> (sqlSession == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SqlSessionException</span>(<span class="string">&quot;Error:  Cannot get connection.  No managed session is started.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSession.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截 sqlSessionProxy 方法调用，使用 localSqlSession 或临时生成一个 SqlSession</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 使用 localSqlSession 执行方法</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionManager.<span class="built_in">this</span>.localSqlSession.get();</span><br><span class="line">            <span class="keyword">if</span> (sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(sqlSession, args);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临时生成一个 SqlSession 执行方法</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">autoSqlSession</span> <span class="operator">=</span> openSession()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(autoSqlSession, args);</span><br><span class="line">                    autoSqlSession.commit();</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    autoSqlSession.rollback();</span><br><span class="line">                    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读源码</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
