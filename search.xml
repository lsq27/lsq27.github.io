<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows 下最好的便携式包管理工具 - Scoop</title>
    <url>/2022/02/07/scoop/</url>
    <content><![CDATA[<h2 id="Scoop-是什么"><a href="#Scoop-是什么" class="headerlink" title="Scoop 是什么"></a>Scoop 是什么</h2><p><a href="https://scoop.sh/">Scoop</a>是一个 Windows 下的命令行安装器。其官网的自我介绍是</p>
<blockquote>
<p>Scoop 以阻力最小的方式从命令行安装您熟悉和喜爱的程序，它可以：</p>
<ul>
<li>消除权限弹出窗口</li>
<li>隐藏安装程序的界面</li>
<li>防止安装大量程序对 PATH 的污染</li>
<li>避免安装和卸载程序的意外副作用</li>
<li>查找并安装依赖项</li>
<li>执行所有额外的程序设置步骤</li>
</ul>
</blockquote>
<h2 id="为什么要用-Scoop"><a href="#为什么要用-Scoop" class="headerlink" title="为什么要用 Scoop"></a>为什么要用 Scoop</h2><p>以前我要安装一个软件，我会</p>
<ul>
<li>搜索引擎搜索 node</li>
<li>打开官网 (注意避开广告！)</li>
<li>寻找适合版本的下载链接，使用下载工具下载</li>
<li>打开安装包配置我需要的参数并安装</li>
</ul>
<p>通过 Scoop 安装一个软件的，只需输入一个命令，Scoop 帮我们</p>
<ul>
<li>下载安装包(压缩包)</li>
<li>安装(解压)</li>
<li>链接安装目录</li>
<li>持久化文件</li>
<li>执行脚本</li>
</ul>
<p>Scoop 不只帮我们省略了找到安装包的过程，还免去了安装时的配置过程(Scoop 在安装脚本中写明了最佳的安装配置)，更妙的是全程都没用到管理员权限，自然也不必担心安装包对操作系统未知的修改(比如偷偷装个证书，设置自己为开机启动)。</p>
<p>和自行安装软件相比，我认为 Scoop 的优点有</p>
<ul>
<li>软件数量多，官方桶中包含约 4000 个软件，第三方桶也有丰富应用</li>
<li>安装不依赖管理员权限，除了极少数特殊软件需要修改注册表或者安装到管理员目录</li>
<li>自动配置，安装时采用默认配置，Scoop 默认把路径设置为自己的目录，开机自启动等设置为否，简化安装步骤</li>
<li>自动安装依赖</li>
<li>自动添加命令行程序的链接到 <code>~/scoop/shims</code> ，然后再将该目录添加到环境变量，自动添加 GUI 程序的快捷方式到开始菜单</li>
<li>比 Linux 的包管理工具更便携的软件管理体验，即使重装系统也能快速恢复软件环境</li>
</ul>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="安装-Scoop"><a href="#安装-Scoop" class="headerlink" title="安装 Scoop"></a>安装 Scoop</h3><p>打开 PowerShell (版本号大于等于 5.1)，执行以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser <span class="comment"># 获取执行脚本权限</span></span><br><span class="line">&gt; <span class="built_in">irm</span> get.scoop.sh | <span class="built_in">iex</span></span><br><span class="line">&gt; <span class="built_in">irm</span> get.scoop.sh <span class="literal">-Proxy</span> <span class="string">&#x27;http://&lt;ip:port&gt;&#x27;</span> | <span class="built_in">iex</span> <span class="comment"># 使用代理连接 GitHub</span></span><br></pre></td></tr></table></figure>

<p>Scoop 会被安装到 <code>C:\Users\&lt;YOUR USERNAME&gt;\scoop</code> 目录下，如果想自定义安装目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">irm</span> get.scoop.sh <span class="literal">-outfile</span> <span class="string">&#x27;install.ps1&#x27;</span></span><br><span class="line">&gt; .\install.ps1 <span class="literal">-ScoopDir</span> <span class="string">&#x27;D:\Applications\Scoop&#x27;</span> <span class="literal">-ScoopGlobalDir</span> <span class="string">&#x27;F:\GlobalScoopApps&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="管理软件"><a href="#管理软件" class="headerlink" title="管理软件"></a>管理软件</h3><h3 id="搜索软件"><a href="#搜索软件" class="headerlink" title="搜索软件"></a>搜索软件</h3><p>搜索可安装软件，列出所有符合条件的软件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop search name</span><br></pre></td></tr></table></figure>

<h4 id="查看已安装软件"><a href="#查看已安装软件" class="headerlink" title="查看已安装软件"></a>查看已安装软件</h4><p>列出已安装软件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop list</span><br></pre></td></tr></table></figure>

<h4 id="查看软件信息"><a href="#查看软件信息" class="headerlink" title="查看软件信息"></a>查看软件信息</h4><p>查看软件信息，如主页，描述，最后更新时间</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop info name</span><br></pre></td></tr></table></figure>

<h4 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h4><p>安装指定名称软件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install nodejs<span class="literal">-lts</span></span><br><span class="line">&gt; node <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<h4 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h4><p>更新指定软件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop update name</span><br><span class="line">&gt; scoop update * <span class="comment"># 更新所有软件</span></span><br></pre></td></tr></table></figure>

<h4 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h4><p>卸载指定软件，执行卸载脚本(删除环境变量等)</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop uninstall name</span><br></pre></td></tr></table></figure>

<h4 id="清理软件"><a href="#清理软件" class="headerlink" title="清理软件"></a>清理软件</h4><p>软件更新后旧版本并不会被卸载，执行命令进行清理</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop uninstall *</span><br></pre></td></tr></table></figure>

<h3 id="桶管理"><a href="#桶管理" class="headerlink" title="桶管理"></a>桶管理</h3><p>桶(bucket)保存着 Scoop 的可安装软件信息。安装完毕后只有一个桶 - main</p>
<h4 id="搜索桶"><a href="#搜索桶" class="headerlink" title="搜索桶"></a>搜索桶</h4><p>只能在 web 中搜索<a href="https://scoop.sh/#/buckets">可用桶</a></p>
<h4 id="列出官方认证的桶"><a href="#列出官方认证的桶" class="headerlink" title="列出官方认证的桶"></a>列出官方认证的桶</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop bucket known</span><br></pre></td></tr></table></figure>

<h4 id="列出已添加桶"><a href="#列出已添加桶" class="headerlink" title="列出已添加桶"></a>列出已添加桶</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop bucket list</span><br></pre></td></tr></table></figure>

<h4 id="添加桶"><a href="#添加桶" class="headerlink" title="添加桶"></a>添加桶</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop bucket add extras <span class="comment"># 含 GUI 的软件</span></span><br><span class="line">&gt; scoop bucket add versions <span class="comment"># 旧版软件</span></span><br><span class="line">&gt; scoop bucket add nerd<span class="literal">-fonts</span> <span class="comment"># 字体</span></span><br><span class="line">&gt; scoop bucket add nonportable <span class="comment"># 非便携软件</span></span><br><span class="line">&gt; scoop bucket add java <span class="comment"># 各种jdk</span></span><br><span class="line">&gt; scoop bucket add dorado https://github.com/chawyehsu/dorado <span class="comment"># 半官方性质的桶</span></span><br></pre></td></tr></table></figure>

<h4 id="删除桶"><a href="#删除桶" class="headerlink" title="删除桶"></a>删除桶</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop bucket <span class="built_in">rm</span> name</span><br></pre></td></tr></table></figure>

<h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><h3 id="优化搜索速度"><a href="#优化搜索速度" class="headerlink" title="优化搜索速度"></a>优化搜索速度</h3><p>scoop 的 search 命令会搜索远程服务器，而 <a href="https://github.com/shilangyu/scoop-search">scoop-search</a> 只搜索本地桶内容</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install scoop<span class="literal">-search</span></span><br><span class="line">&gt; scoop<span class="literal">-search</span> name</span><br></pre></td></tr></table></figure>

<h3 id="软件重名"><a href="#软件重名" class="headerlink" title="软件重名"></a>软件重名</h3><p>如果软件重名，使用如下方式安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install bucket/name</span><br></pre></td></tr></table></figure>

<h3 id="指定软件版本"><a href="#指定软件版本" class="headerlink" title="指定软件版本"></a>指定软件版本</h3><p>如果要安装旧版软件且 versions 中没有，使用如下方式安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop install name@version</span><br></pre></td></tr></table></figure>

<p>一个该软件的 manifest 将会被生成在 <code>~\scoop\workspace</code>，该软件将不会被更新</p>
<h3 id="多版本软件优先级"><a href="#多版本软件优先级" class="headerlink" title="多版本软件优先级"></a>多版本软件优先级</h3><p>如果你安装了一个软件的多个衍生版本，例如 temurin-lts-jdk 和 temurin8-jdk，最后一个安装的版本将会在命令行生效，如果需要在命令行使用其他版本，执行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; scoop reset name</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>package manager</tag>
        <tag>Scoop</tag>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/10/spring-spi/</url>
    <content><![CDATA[<h1 id="Spring-Boot-SPI-机制探究"><a href="#Spring-Boot-SPI-机制探究" class="headerlink" title="Spring Boot SPI 机制探究"></a>Spring Boot SPI 机制探究</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring Boot 带给我们的一大便利是当需要引入一个第三方依赖时，如果其有 Starter，可以加入 Starter 依赖，就可以实现自动装配，这中便利就来自 Spring Boot 独特的 SPI 机制。</p>
<p>比如项目中希望引入 Mybatis，只需在 POM 中加入以下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>剩下的工作就是定义 Mapper 并使用，中间所有繁杂的配置 Starter 都帮忙做了。如此神奇的功能其实实现原理十分简单，下文进行分析。</p>
<h2 id="获取配置类的全限定名"><a href="#获取配置类的全限定名" class="headerlink" title="获取配置类的全限定名"></a>获取配置类的全限定名</h2><p>从 <code>@SpringBootApplication</code> 注解一路向下寻找，依次找<code>@EnableAutoConfiguration</code>、<code>@Import(AutoConfigurationImportSelector.class)</code>、<code>getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)</code>，可以看到熟悉的 <code>spring.factories</code>，此处调用的两个函数即为 Spring SPI 的扫描逻辑，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; configurations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">		SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));</span><br><span class="line">ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line">		<span class="string">&quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you &quot;</span></span><br><span class="line">				+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a><code>META-INF/spring.factories</code></h3><p>第一种方式是读取 classpath 中的所有 <code>META-INF/spring.factories</code> 文件，此处有三个循环，第一层遍历获取到的文件位置，第二层遍历文件中的属性，第三层遍历每个属性用 <code>,</code> 分割后的字符串（类路径），这样就获取到了所有需要进行装配的 Configuration 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">	<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">	<span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">	<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">		String[] factoryImplementationNames =</span><br><span class="line">				StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">		<span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">			result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">					.add(factoryImplementationName.trim());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="META-INF-spring-org-springframework-boot-autoconfigure-AutoConfiguration-imports"><a href="#META-INF-spring-org-springframework-boot-autoconfigure-AutoConfiguration-imports" class="headerlink" title="META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports"></a><code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></h3><p>在 Spring Boot 2.7.0 中，增加了对另一种自动配置方式的支持，即读取资源文件 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件，第一层遍历获取到的文件位置，第二层遍历文件中的行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> String.format(LOCATION, annotation.getName());</span><br><span class="line">Enumeration&lt;URL&gt; urls = findUrlsInClasspath(classLoaderToUse, location);</span><br><span class="line">List&lt;String&gt; importCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">	<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">	importCandidates.addAll(readCandidateConfigurations(url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>得到类名后，Spring 利用 <code>Class.forName</code> 将所有需要进行装配的配置类进行加载实例化，不再赘述。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习编码的过程中不能被像 SPI 看起来高深的概念所迷惑，看起来很神奇的自动装配功能其实归根到底就是读取特定名称的配置文件，然后反射获取配置类。</p>
]]></content>
  </entry>
  <entry>
    <title>在 Windows 下愉快地使用 SSH</title>
    <url>/2023/04/01/ssh/</url>
    <content><![CDATA[<p>Windows 现在自带OpenSSH客户端，配合git进行使用</p>
<span id="more"></span>

<h2 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h2><p>使用 <code>Ed25519</code> 算法生成 SSH key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>确认生成路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (C:\Users\you/.ssh/id_ed25519):</span><br></pre></td></tr></table></figure>

<p>输入两次 passphrase，可以为空，为空时一旦有人获取私钥，则可以访问所有配置了该私钥的系统，不建议为空。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line"></span><br><span class="line">Enter same passphrase again:</span><br><span class="line"></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> C:\Users\you/.ssh/id_ed25519</span><br><span class="line"></span><br><span class="line">Your public key has been saved <span class="keyword">in</span> C:\Users\you/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure>

<p>生成后相应目录会产生两个文件，<code>.pub</code>后缀为公钥，另一个为私钥。</p>
<h2 id="使用-SSH-Key"><a href="#使用-SSH-Key" class="headerlink" title="使用 SSH Key"></a>使用 SSH Key</h2><p>使用方式以<code>GitHub</code>为例，进入<code>Settings</code>-&gt;<code>SSH and GPG keys</code>-&gt;<code>New SSH key</code>，将公钥内容粘贴进<code>Key</code>框中，点击<code>Add SSH key</code>，</p>
<p>测试 github 认证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;C:\Users\you/.ssh/id_ed25519&#x27;</span>:</span><br><span class="line"></span><br><span class="line">Hi xxx! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-ssh-agent"><a href="#配置-ssh-agent" class="headerlink" title="配置 ssh-agent"></a>配置 ssh-agent</h2><p>在做完以上步骤后， SHH Key 已经可以正常使用了，但是每次都要输入 passphrase，十分麻烦，可以利用 ssh-agent 对私钥解密结果进行缓存。</p>
<p>使用键盘输入 <code>Win</code> + <code>R</code>，输入<code>services.msc</code>进入服务。打开<code>OpenSSH Authentication Agent</code>项目，启动类型选择自动或自动(延迟启动)，点击启动。</p>
<p>添加 SSH key 到 ssh-agent</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh-add</span><br><span class="line"></span><br><span class="line">Enter passphrase <span class="keyword">for</span> C:\Users\lusha/.ssh/id_ed25519:</span><br><span class="line"></span><br><span class="line">Identity added: C:\Users\you/.ssh/id_ed25519 (your_email@example.com)</span><br></pre></td></tr></table></figure>

<p>操作完成后，删除私钥文件。建议将私钥文件加密备份，以防操作系统重装等因素导致私钥丢失</p>
<h2 id="GPG"><a href="#GPG" class="headerlink" title="GPG"></a>GPG</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --full-generate-key</span><br><span class="line">gpg (GnuPG) 2.2.29-unknown; Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">gpg: directory <span class="string">&#x27;/c/Users/lusha/.gnupg&#x27;</span> created</span><br><span class="line">gpg: keybox <span class="string">&#x27;/c/Users/lusha/.gnupg/pubring.kbx&#x27;</span> created</span><br><span class="line">Please select what kind of key you want:</span><br><span class="line">   (1) RSA and RSA (default)</span><br><span class="line">   (2) DSA and Elgamal</span><br><span class="line">   (3) DSA (sign only)</span><br><span class="line">   (4) RSA (sign only)</span><br><span class="line">  (14) Existing key from card</span><br><span class="line">Your selection? 1</span><br><span class="line">RSA keys may be between 1024 and 4096 bits long.</span><br><span class="line">What keysize <span class="keyword">do</span> you want? (3072) 4096</span><br><span class="line">Requested keysize is 4096 bits</span><br><span class="line">Please specify how long the key should be valid.</span><br><span class="line">         0 = key does not expire</span><br><span class="line">      &lt;n&gt;  = key expires <span class="keyword">in</span> n days</span><br><span class="line">      &lt;n&gt;w = key expires <span class="keyword">in</span> n weeks</span><br><span class="line">      &lt;n&gt;m = key expires <span class="keyword">in</span> n months</span><br><span class="line">      &lt;n&gt;y = key expires <span class="keyword">in</span> n years</span><br><span class="line">Key is valid <span class="keyword">for</span>? (0)</span><br><span class="line">Key does not expire at all</span><br><span class="line">Is this correct? (y/N) y</span><br><span class="line"></span><br><span class="line">GnuPG needs to construct a user ID to identify your key.</span><br><span class="line"></span><br><span class="line">Real name: lsq27</span><br><span class="line">Email address: lushaoqiang27@gmail.com</span><br><span class="line">Comment:</span><br><span class="line">You selected this USER-ID:</span><br><span class="line">    <span class="string">&quot;lsq27 &lt;lushaoqiang27@gmail.com&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O</span><br><span class="line">We need to generate a lot of random bytes. It is a good idea to perform</span><br><span class="line">some other action (<span class="built_in">type</span> on the keyboard, move the mouse, utilize the</span><br><span class="line">disks) during the prime generation; this gives the random number</span><br><span class="line">generator a better chance to gain enough entropy.</span><br><span class="line">We need to generate a lot of random bytes. It is a good idea to perform</span><br><span class="line">some other action (<span class="built_in">type</span> on the keyboard, move the mouse, utilize the</span><br><span class="line">disks) during the prime generation; this gives the random number</span><br><span class="line">generator a better chance to gain enough entropy.</span><br><span class="line">gpg: /c/Users/lusha/.gnupg/trustdb.gpg: trustdb created</span><br><span class="line">gpg: key 14F807AABAA53E8E marked as ultimately trusted</span><br><span class="line">gpg: directory <span class="string">&#x27;/c/Users/lusha/.gnupg/openpgp-revocs.d&#x27;</span> created</span><br><span class="line">gpg: revocation certificate stored as <span class="string">&#x27;/c/Users/lusha/.gnupg/openpgp-revocs.d/99A618713B52EF6F70AE461A14F807AABAA53E8E.rev&#x27;</span></span><br><span class="line">public and secret key created and signed.</span><br><span class="line"></span><br><span class="line">pub   rsa4096 2023-03-31 [SC]</span><br><span class="line">      99A618713B52EF6F70AE461A14F807AABAA53E8E</span><br><span class="line">uid                      lsq27 &lt;lushaoqiang27@gmail.com&gt;</span><br><span class="line">sub   rsa4096 2023-03-31 [E]</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>转载请注明出处，使用时须遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0 License</a> 中所述条款。</p>
</blockquote>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>GPG</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>
