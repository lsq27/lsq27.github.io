<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据库分页排序数据重复</title>
    <url>/2024/paging-sorting-data-duplication/</url>
    <content><![CDATA[<p>在需求测试中碰到了分页排序数据重复的问题，在翻页时发现部分数据在多页中出现。初次碰到感觉该问题比较反直觉，排序和分页放在一起用时，在我看来应该是先排序再分页，排序顺序确定的情况下，分页每次取部分数据，是不应该出现数据重复出现在不同页的情况的。</p>
<span id="more"></span>

<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>开发环境用的是 <code>Oracle</code>，在自己的电脑用 <code>MySQL</code> 也可以复现问题，<code>MySQL</code> 版本采用 8.2.0。</p>
<h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>新建如下表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入如下数据</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>9</td>
<td>3</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>现在进行分页查询，每页两条数据，查询第一页数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">0</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
</tr>
</tbody></table>
<p>查询第二页数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">2</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>预期的结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>x</td>
<td>2</td>
</tr>
</tbody></table>
<p>实际结果如下</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>可以看到，id 为 10 的数据在两次分页查询中出现了两次，id 为 5 的数据从未出现。通过分页查询，用户永远也无法看到 id 为 5 的数据。</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>查询相关资料，MySQL 的文档其实说明了原因<br><a href="https://dev.mysql.com/doc/refman/8.3/en/limit-optimization.html">MySQL :: MySQL 8.3 Reference Manual :: 8.2.1.19 LIMIT Query Optimization</a></p>
<blockquote>
<p>If multiple rows have identical values in the <code>ORDER BY</code> columns, the server is free to return those rows in any order, and may do so differently depending on the overall execution plan. In other words, the sort order of those rows is nondeterministic with respect to the nonordered columns.</p>
<p>One factor that affects the execution plan is <code>LIMIT</code>, so an <code>ORDER BY</code> query with and without <code>LIMIT</code> may return rows in different orders.</p>
</blockquote>
<p>简言之，<code>ORDER BY</code> 的列如果值相同，数据库不保证返回行的顺序，结果受整体执行计划影响。</p>
<p>那么文章开头问题的原因显而易见，<code>LIMIT</code>改变了执行计划，<code>ORDER BY</code> 受此影响，对不同的<code>LIMIT</code>参数返回了顺序不同的结果行，通过以下<code>SQL</code>可以证实</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">0</span>,<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>执行结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>从第 3 行起取 2 行结果，与查询第二页数据结果一致。</p>
<p><strong><code>ORDER BY</code> 的结果顺序受执行计划影响， <code>LIMIT</code> 改变了执行计划，导致了分页排序数据重复问题的发生。</strong></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>MySQL</code>文档给的解决方案是在<code>ORDER BY</code> 的字段中增加不含重复值的列，如<code>id</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name, id limit <span class="number">0</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> name, id limit <span class="number">2</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>问题解决。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>执行文中的<code>SQL</code>时，执行计划中均出现了 <code>Using filesort</code>，之后另起一篇分析一下<code>MySQL</code>的排序算法，找到本文问题的代码根源。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>test</td>
<td></td>
<td>ALL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>10</td>
<td>100.0</td>
<td>Using filesort</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>解决问题</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>生产问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 的三种 IO 模型</title>
    <url>/2023/tomcat-io/</url>
    <content><![CDATA[<p>在用 Java 手写服务器示例代码的时候有一些疑惑，加之日常开发中只对 Tomcat 有浅显的理解，知道其是用线程池处理请求，所以就翻了翻 Tomcat 的源代码。本文记录 Tomcat 中 IO 模型的相关代码，版本为 tomcat-embed-core:9.0.78。</p>
<span id="more"></span>

<p>Tomcat 支持的 IO 模型有 APR、NIO、NIO2 三种。</p>
<p>APR、NIO 两种实现方式本质上都是 reactor 模式，使用 IO 多路复用和线程池实现并发处理多个客户端请求。使用的是主从 reactor 多线程模型。其中 acceptor 为主 reactor，负责接受新连接。poller 为从 reactor，负责监控 IO 事件，worker 为执行 IO 操作和业务代码的线程池。</p>
<h2 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h2><p>Tomcat 中封装 IO 相关方法的类叫做 endpoint，负责创建 acceptor, poller, worker 等对象，并负责这几个类之间的交互，作用是胶水代码。<br>抽象类为 AbstractEndpoint，具体的子类有 AprEndpoint、NioEndpoint 和 Nio2Endpoint，分别代表 APR、NIO 和 NIO2 三种 IO 模型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEndpoint</span>&lt;S,U&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * endpoint 的入口，用于启动 acceptor, poller, worker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 worker 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        internalExecutor = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (getUseVirtualThreads()) &#123;</span><br><span class="line">            <span class="comment">// 创建 Java 21 虚拟线程池</span></span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">VirtualThreadExecutor</span>(getName() + <span class="string">&quot;-virt-&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建多线程线程池，默认核心线程数 10，最大线程数 200，优先级 5</span></span><br><span class="line">            <span class="type">TaskQueue</span> <span class="variable">taskqueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">            <span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">            taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并启动 acceptor 线程，APR, NIO 使用该默认实现，NIO2 重写了该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startAcceptorThread</span><span class="params">()</span> &#123;</span><br><span class="line">        acceptor = <span class="keyword">new</span> <span class="title class_">Acceptor</span>&lt;&gt;(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> getName() + <span class="string">&quot;-Acceptor&quot;</span>;</span><br><span class="line">        acceptor.setThreadName(threadName);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(acceptor, threadName);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受连接，被 acceptor 调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> U <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置连接，被 acceptor 调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(U socket)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 socket 事件，被 poller 调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span><br><span class="line"><span class="params">            SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 socket 处理器</span></span><br><span class="line">            SocketProcessorBase&lt;S&gt; sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">            <span class="comment">// 处理 socket 事件，根据 dispatch 判断是否使用 worker 处理</span></span><br><span class="line">            <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getExecutor();</span><br><span class="line">            <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="literal">null</span>) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 socket 处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> SocketProcessorBase&lt;S&gt; <span class="title function_">createSocketProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">            SocketWrapperBase&lt;S&gt; socketWrapper, SocketEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AprEndpoint"><a href="#AprEndpoint" class="headerlink" title="AprEndpoint"></a>AprEndpoint</h3><p>该类将在 Tomcat 10 被废弃，APR 通过 JNI 进行 socket 操作，相比使用 Java IO API 效率更高。<br>使用该类会创建以下线程（池）</p>
<ul>
<li>acceptor 线程</li>
<li>poller 线程</li>
<li>sendfile 线程</li>
<li>worker 线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AprEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractEndpoint</span>&lt;Long,Long&gt; <span class="keyword">implements</span> <span class="title class_">SNICallBack</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">serverSock</span> <span class="operator">=</span> Socket.create(family, Socket.SOCK_STREAM, <span class="number">0</span>, rootPool);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Socket.bind(serverSock, sockAddress);</span><br><span class="line">        ret = Socket.listen(serverSock, getAcceptCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 APR endpoint，启动 acceptor, poller, sendfile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            running = <span class="literal">true</span>;</span><br><span class="line">            paused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 worker 线程池</span></span><br><span class="line">            <span class="keyword">if</span> (getExecutor() == <span class="literal">null</span>) &#123;</span><br><span class="line">                createExecutor();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 poller 线程</span></span><br><span class="line">            poller = <span class="keyword">new</span> <span class="title class_">Poller</span>();</span><br><span class="line">            poller.init();</span><br><span class="line">            poller.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 sendfile 线程</span></span><br><span class="line">            <span class="keyword">if</span> (getUseSendfile()) &#123;</span><br><span class="line">                sendfile = <span class="keyword">new</span> <span class="title class_">Sendfile</span>();</span><br><span class="line">                sendfile.init();</span><br><span class="line">                sendfile.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 acceptor 线程</span></span><br><span class="line">            startAcceptorThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AprEndpoint 接受连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">socket</span> <span class="operator">=</span> Socket.accept(serverSock);</span><br><span class="line">        <span class="keyword">return</span> Long.valueOf(socket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AprEndpoint 设置连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(Long socket)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">AprSocketWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AprSocketWrapper</span>(socket, <span class="built_in">this</span>);</span><br><span class="line">            connections.put(socket, wrapper);</span><br><span class="line">            wrapper.setKeepAliveLeft(getMaxKeepAliveRequests());</span><br><span class="line">            wrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            wrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            getExecutor().execute(<span class="keyword">new</span> <span class="title class_">SocketWithOptionsProcessor</span>(wrapper));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把socket交给poller处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">SocketWithOptionsProcessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> socket.getLock();</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getPoller().add(socket.getSocket().longValue(), getConnectionTimeout(), Poll.APR_POLLIN);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NioEndpoint"><a href="#NioEndpoint" class="headerlink" title="NioEndpoint"></a>NioEndpoint</h3><p>NioEndpoint 通过 Java NIO 进行同步非阻塞 IO 操作。相比使用同步阻塞 IO，大大减少了高并发下所需线程的数量，因而效率更高。</p>
<p>使用该类会创建以下线程（池）</p>
<ul>
<li>acceptor 线程（阻塞接受新连接）</li>
<li>poller 线程（配置 IO 多路复用，检测 IO 事件）</li>
<li>worker 线程池（处理 IO 事件）</li>
</ul>
<p>acceptor 循环接受连接并将注册事件放入 poller 的事件队列，poller 循环处理事件队列中的事件并检测 IO 事件，如果发生 IO 事件让 worker 进行 IO 操作并执行业务代码。</p>
<p>功能示意图如下</p>
<p><img src="/2023/tomcat-io/nio.png" alt="NIO"></p>
<p>向服务器发出一个请求，查看线程状态。编号 1-10 的线程为 worker 线程。</p>
<p><img src="/2023/tomcat-io/nio%E7%BA%BF%E7%A8%8B.png" alt="NIO thread"></p>
<p>收到请求后，一个 worker 线程由 Park 状态转为 Running 状态；接着服务器访问外部服务，等待 IO 期间线程转为 Wait 状态；访问外部服务完成后整个请求结束，线程又转为 Park 状态。</p>
<p>NIO 相关代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel,SocketChannel&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getAddress(), getPortWithOffset());</span><br><span class="line">        serverSock.bind(addr, getAcceptCount());</span><br><span class="line">        serverSock.configureBlocking(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 NIO endpoint，启动 acceptor, poller</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            running = <span class="literal">true</span>;</span><br><span class="line">            paused = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 创建 worker 线程池</span></span><br><span class="line">            <span class="keyword">if</span> (getExecutor() == <span class="literal">null</span>) &#123;</span><br><span class="line">                createExecutor();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动 poller 线程</span></span><br><span class="line">            poller = <span class="keyword">new</span> <span class="title class_">Poller</span>();</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">pollerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(poller, getName() + <span class="string">&quot;-Poller&quot;</span>);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">            <span class="comment">// 启动 acceptor 线程</span></span><br><span class="line">            startAcceptorThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NioEndpoint 接受连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SocketChannel <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 阻塞接受连接</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">result</span> <span class="operator">=</span> serverSock.accept();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NioEndpoint 设置连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(SocketChannel socket)</span> &#123;</span><br><span class="line">        <span class="type">NioSocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketBufferHandler</span> <span class="variable">bufhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketBufferHandler</span>(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="type">NioChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioChannel</span>(bufhandler);</span><br><span class="line">            <span class="type">NioSocketWrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioSocketWrapper</span>(channel, <span class="built_in">this</span>);</span><br><span class="line">            channel.reset(socket, newWrapper);</span><br><span class="line">            connections.put(socket, newWrapper);</span><br><span class="line">            socketWrapper = newWrapper;</span><br><span class="line">            <span class="comment">// 因使用 IO 多路复用，设置为非阻塞 IO</span></span><br><span class="line">            socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (getUnixDomainSocketPath() == <span class="literal">null</span>) &#123;</span><br><span class="line">                socketProperties.setProperties(socket.socket());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            socketWrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setKeepAliveLeft(NioEndpoint.<span class="built_in">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">            <span class="comment">// 将 socket 注册到 poller</span></span><br><span class="line">            poller.register(socketWrapper);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nio2Endpoint"><a href="#Nio2Endpoint" class="headerlink" title="Nio2Endpoint"></a>Nio2Endpoint</h3><p>Nio2Endpoint 通过 Java NIO 进行异步 IO 操作，相比使用同步非阻塞 IO，应用不需将数据拷贝到进程中，而由内核代为完成后通知应用，执行回调。Java 异步 IO 在 Windows 中通过 IOCP 实现，在 Linux 中通过 epoll 模拟实现，所以理论上在 Linux 下同步非阻塞 IO 和异步 IO 的效率无明显差别。</p>
<p>使用该类会创建以下线程（池）</p>
<ul>
<li>acceptor 线程</li>
<li>worker 线程池</li>
</ul>
<p>相比同步非阻塞 IO，少了 poller，操作系统承担了 poller 的工作和。</p>
<p>功能示意图如下</p>
<p><img src="/2023/tomcat-io/nio2.png" alt="NIO2"></p>
<p>向服务器发出一个请求，查看线程状态。编号 1-10 的线程为 worker 线程。</p>
<p><img src="/2023/tomcat-io/nio2%E7%BA%BF%E7%A8%8B.png" alt="NIO2 thread"></p>
<p>收到请求后，一个 worker 线程由 Park 状态转为 Running 状态；接着服务器访问外部服务，等待 IO 期间线程转为 Wait 状态；访问外部服务完成后整个请求结束，线程又转为 Park 状态。</p>
<p>NIO2 相关代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO2 endpoint.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nio2Endpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;Nio2Channel,AsynchronousSocketChannel&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并监听地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 使用 worker 线程池处理 IO 事件</span></span><br><span class="line">        threadGroup = AsynchronousChannelGroup.withThreadPool((ExecutorService) getExecutor());</span><br><span class="line">        serverSock = AsynchronousServerSocketChannel.open(threadGroup);</span><br><span class="line">        socketProperties.setProperties(serverSock);</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getAddress(), getPortWithOffset());</span><br><span class="line">        <span class="comment">// 绑定地址</span></span><br><span class="line">        serverSock.bind(addr, getAcceptCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 NIO2 endpoint, 启动 acceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建 worker 线程池</span></span><br><span class="line">        <span class="keyword">if</span> (getExecutor() == <span class="literal">null</span>) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动 acceptor 线程</span></span><br><span class="line">        startAcceptorThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 NIO2 acceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startAcceptorThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">            acceptor = <span class="keyword">new</span> <span class="title class_">Nio2Acceptor</span>(<span class="built_in">this</span>);</span><br><span class="line">            acceptor.setThreadName(getName() + <span class="string">&quot;-Acceptor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 worker 线程池启动 accepor</span></span><br><span class="line">        getExecutor().execute(acceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞接受连接，该方法未被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AsynchronousSocketChannel <span class="title function_">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AsynchronousSocketChannel</span> <span class="variable">result</span> <span class="operator">=</span> serverSock.accept().get();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Nio2Endpoint 设置连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(AsynchronousSocketChannel socket)</span> &#123;</span><br><span class="line">        <span class="type">Nio2SocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketBufferHandler</span> <span class="variable">bufhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketBufferHandler</span>(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="type">Nio2Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Nio2Channel</span>(bufhandler);</span><br><span class="line">            <span class="type">Nio2SocketWrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Nio2SocketWrapper</span>(channel, <span class="built_in">this</span>);</span><br><span class="line">            channel.reset(socket, newWrapper);</span><br><span class="line">            connections.put(socket, newWrapper);</span><br><span class="line">            socketWrapper = newWrapper;</span><br><span class="line"></span><br><span class="line">            socketProperties.setProperties(socket);</span><br><span class="line">            socketWrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setKeepAliveLeft(Nio2Endpoint.<span class="built_in">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">            <span class="comment">// 调用 AbstractEndpoint.processSocket 方法处理 IO 事件。因为是异步 IO，所以不需要使用新线程处理 IO 事件</span></span><br><span class="line">            <span class="keyword">return</span> processSocket(socketWrapper, SocketEvent.OPEN_READ, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">SocketProcessor</span> <span class="keyword">extends</span> <span class="title class_">SocketProcessorBase</span>&lt;Nio2Channel&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被 AbstractEndpoint.processSocket 调用，处理 IO 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">launch</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketState</span> <span class="variable">state</span> <span class="operator">=</span> SocketState.OPEN;</span><br><span class="line">            <span class="comment">// 处理 IO 事件</span></span><br><span class="line">            <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">                state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = getHandler().process(socketWrapper, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (state == SocketState.UPGRADING) &#123;</span><br><span class="line">                launch = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (launch) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 使用新线程处理 IO 事件</span></span><br><span class="line">                    getExecutor().execute(<span class="keyword">new</span> <span class="title class_">SocketProcessor</span>(socketWrapper, SocketEvent.OPEN_READ));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h2><p>acceptor 的功能如其名称，用于接受 socket 连接请求。产生一个与客户端的连接的 socket 后，再将其交给 poller 处理。<br>acceptor 的代码逻辑特别简单，不断地调用 <code>endpoint.serverSocketAccept</code> 产生 socket 连接，调用 <code>endpoint.setSocketOptions</code> 设置 socket。</p>
<h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h3><p>NIO、APR 的 acceptor 为类 Acceptor，Acceptor 主要代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span>&lt;U&gt; <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线程中循环接受新连接直到收到关闭命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">errorDelay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stopCalled) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 接受连接</span></span><br><span class="line">                <span class="type">U</span> <span class="variable">socket</span> <span class="operator">=</span> endpoint.serverSocketAccept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</span><br><span class="line">                <span class="comment">// 连接失败进行延时操作</span></span><br><span class="line">                errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// endpoint 设置连接，处理失败则关闭连接</span></span><br><span class="line">            <span class="keyword">if</span> (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                endpoint.closeSocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时时长指数增加，防止短时间内产生大量错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_ERROR_DELAY</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ERROR_DELAY</span> <span class="operator">=</span> <span class="number">1600</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">handleExceptionWithDelay</span><span class="params">(<span class="type">int</span> currentErrorDelay)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次不延时</span></span><br><span class="line">        <span class="keyword">if</span> (currentErrorDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Thread.sleep(currentErrorDelay);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentErrorDelay == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INITIAL_ERROR_DELAY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentErrorDelay &lt; MAX_ERROR_DELAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentErrorDelay * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MAX_ERROR_DELAY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nio2Acceptor"><a href="#Nio2Acceptor" class="headerlink" title="Nio2Acceptor"></a>Nio2Acceptor</h3><p>NIO2 中的 acceptor 为类 Nio2Acceptor，Nio2Acceptor 重写了 Acceptor 的 <code>run</code> 方法，用异步 IO 替代同步 IO。且实现了 CompletionHandler 接口，用于处理异步 IO 完成事件。</p>
<p>Nio2Acceptor 的主要代码如下，其中没有调用 <code>endpoint.serverSocketAccept</code> 产生 socket，而是直接调用 <code>serverSock.accept</code> 产生 socket，另一个异同是 Nio2Acceptor 的 run 方法中没有循环，而是通过异步 IO 的回调函数重新接受新请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Nio2Acceptor</span> <span class="keyword">extends</span> <span class="title class_">Acceptor</span>&lt;AsynchronousSocketChannel&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果达到最大连接数，等待</span></span><br><span class="line">        countUpOrAwaitConnection();</span><br><span class="line">        <span class="comment">// 异步 IO，连接完成后由 completed 方法处理，失败由 failed 方法处理</span></span><br><span class="line">        serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接请求成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socket,</span></span><br><span class="line"><span class="params">            Void attachment)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步接受新请求</span></span><br><span class="line">        <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;</span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getConnectionCount() &lt; getMaxConnections()) &#123;</span><br><span class="line">            countUpOrAwaitConnection();</span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 达到最大连接数，使用新线程接受请求</span></span><br><span class="line">            getExecutor().execute(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 socket</span></span><br><span class="line">        <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">            closeSocket(socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接请求失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable t, Void attachment)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;</span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用新线程接受请求</span></span><br><span class="line">            getExecutor().execute(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownConnection();</span><br><span class="line">        <span class="comment">// 失败后等待一段事件</span></span><br><span class="line">        errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poller"><a href="#poller" class="headerlink" title="poller"></a>poller</h2><p>poller 的作用是将新 socket 注册到 selector 并轮询是否有 IO 事件发生。</p>
<h3 id="APR-poller"><a href="#APR-poller" class="headerlink" title="APR poller"></a>APR poller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        pollerThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(poller, getName() + <span class="string">&quot;-Poller&quot;</span>);</span><br><span class="line">        pollerThread.setPriority(threadPriority);</span><br><span class="line">        pollerThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        pollerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SocketList</span> <span class="variable">localAddList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketList</span>(getMaxConnections());</span><br><span class="line">        <span class="keyword">while</span> (pollerRunning) &#123;</span><br><span class="line">            <span class="type">SocketInfo</span> <span class="variable">info</span> <span class="operator">=</span> localAddList.get();</span><br><span class="line">            <span class="keyword">while</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// poll 操作</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rv</span> <span class="operator">=</span> Poll.poll(aprPoller, pollTime, desc, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; rv; n++) &#123;</span><br><span class="line">                    processSocket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NIO-poller"><a href="#NIO-poller" class="headerlink" title="NIO poller"></a>NIO poller</h3><p>poller 负责两件事，处理 poller 事件，处理 IO 事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">wakeupCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// IO 多路复用选择器</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">// poller 事件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronizedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 socket 的读事件注册到事件队列中，被 acceptor 调用 setSocketOptions 时间接调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> NioSocketWrapper socketWrapper)</span> &#123;</span><br><span class="line">        socketWrapper.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        <span class="type">PollerEvent</span> <span class="variable">pollerEvent</span> <span class="operator">=</span> createPollerEvent(socketWrapper, OP_REGISTER);</span><br><span class="line">        addEvent(pollerEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEvent</span><span class="params">(PollerEvent event)</span> &#123;</span><br><span class="line">        events.offer(event);</span><br><span class="line">        <span class="comment">// wakeupCounter 为 -1 时唤醒 selector，处理新事件</span></span><br><span class="line">        <span class="keyword">if</span> (wakeupCounter.incrementAndGet() == <span class="number">0</span>) &#123;</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环处理 poller 事件和 IO 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasEvents</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hasEvents = events();</span><br><span class="line">                <span class="comment">// 事件队列有新事件，wakeupCounter 为 -1 时，selector 正在进行 select 操作</span></span><br><span class="line">                <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 检查有没有 IO，有 IO 先处理 IO</span></span><br><span class="line">                    keyCount = selector.selectNow();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有新事件就等待已注册 IO 的，默认超时 1000ms</span></span><br><span class="line">                    keyCount = selector.select(selectorTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 没有 socket 可读写</span></span><br><span class="line">                <span class="keyword">if</span> (keyCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    hasEvents = (hasEvents | events());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历 selector key，处理 IO 事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (iterator != <span class="literal">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="type">NioSocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> (NioSocketWrapper) sk.attachment();</span><br><span class="line">                processKey(sk, socketWrapper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理超时的连接</span></span><br><span class="line">            timeout(keyCount,hasEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        getStopLatch().countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 poller 事件队列中的事件，如果处理了事件返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">events</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PollerEvent</span> <span class="variable">pe</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != <span class="literal">null</span>; i++ ) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">NioSocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> pe.getSocketWrapper();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> socketWrapper.getSocket().getIOChannel();</span><br><span class="line">            <span class="comment">// 注册读事件到 selector</span></span><br><span class="line">            sc.register(getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 IO 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper socketWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sk.isReadable() || sk.isWritable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (socketWrapper.getSendfileData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                processSendfile(sk, socketWrapper, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 先读再写</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    processSocket(socketWrapper, SocketEvent.OPEN_READ, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sk.isWritable()) &#123;</span><br><span class="line">                    processSocket(socketWrapper, SocketEvent.OPEN_WRITE, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AprEndpoint-1"><a href="#AprEndpoint-1" class="headerlink" title="AprEndpoint"></a>AprEndpoint</h3><p>跟 NioEndpoint 一样，AprEndpoint 也实现了非阻塞 I&#x2F;O，它们的区别是：NioEndpoint 通过调用 Java 的 NIO API 来实现非阻塞 I&#x2F;O，而 AprEndpoint 是通过 JNI 调用 APR 本地库而实现非阻塞 I&#x2F;O 的。在某些场景下，比如需要频繁与操作系统进行交互，Socket 网络通信就是这样一个场景， 特别是如果你的 Web 应用使用了 TLS 来加密传输，我们知道 TLS 协议在握手过程中有多 次网络交互，在这种情况下 Java 跟 C 语言程序相比还是有一定的差距，而这正是 APR 的 强项。Tomcat 本身是 Java 编写的，为了调用 C 语言编写的 APR，需要通过 JNI 方式来调用。 JNI（Java Native Interface） 是 JDK 提供的一个编程接口，它允许 Java 程序调用其他语 言编写的程序或者代码库，其实 JDK 本身的实现也大量用到 JNI 技术来调用本地 C 程序 库。</p>
<p>它跟 NioEndpoint 的工作原理很像，有 LimitLatch、Acceptor、Poller、 SocketProcessor 和 Http11Processor，只是 Acceptor 和 Poller 的实现和 NioEndpoint 不同。</p>
<p>Acceptor 接收到一个新的 Socket 连接后，按照 NioEndpoint 的实现，它会把这个 Socket 交给 Poller 去查询 I&#x2F;O 事件。AprEndpoint 也是这样做的，不过 AprEndpoint 的 Poller 并不是调用 Java NIO 里的 Selector 来查询 Socket 的状态，而是通过 JNI 调用 APR 中的 poll 方法，而 APR 又是调用了操作系统的 epoll API 来实现的。在 AprEndpoint 中，我们可以配置一个叫 deferAccept 的参数，它对应的是 TCP 协议中的 TCP_DEFER_ACCEPT，设置这个参数后，当 TCP 客户端有新的连接请求到达时，TCP 服务端先不建立连接，而是再等等，直到客户端有请求数据发过来时再建立连接。这样的好处是服务端不需要用 Selector 去反复查询请求数据是否就绪。这是一种 TCP 协议层的优化，不是每个操作系统内核都支持，因为 Java 作为一种跨平台语言，需要屏蔽各种操作系统的差异，因此并没有把这个参数提供给用户；但是对于 APR 来说，它的目的就是尽可能提升性能，因此它向用户暴露了这个参数。</p>
<h3 id="Nio2Endpoint-1"><a href="#Nio2Endpoint-1" class="headerlink" title="Nio2Endpoint"></a>Nio2Endpoint</h3><p>接口，</p>
<p>Accpetor 的功能就是监听连接，接收并建立连接。它的本质就是调用了四个操作系统 API：socket、bind、listen 和 accept。那 Java 语言如何直接调用 C 语言 API 呢？答案 就是通过 JNI。</p>
<p>其中两个重要组件：Acceptor 和 SocketProcessor。</p>
<p>Acceptor 用于监听 Socket 连接请求，SocketProcessor 用于处理收到的 Socket 请求，提交到线程池 Executor 处理。</p>
]]></content>
  </entry>
</search>
